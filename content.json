{"pages":[{"title":"","text":"ONE PIECE（ワンピース） 图片均来源于网络，如有版权问题请联系我（留言或邮件），我会立马删除，谢谢！","link":"/album/index.html"},{"title":"","text":"有啥想问的，有啥想搭讪的，都阔以，来者不拒~PS: 禁止发有违国家法律及少儿不宜相关图片及视频哈","link":"/bbs/index.html"},{"title":"","text":"Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything – all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart. “记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情, 包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧,这些在死亡面前都会消失。我看到的是留下的真正重要的东西。你有时候会思考你将会失去某些东西,“记住你即将死去”是我知道的避免这些想法的最好办法。你已经赤身裸体了, 你没有理由不去跟随自己的心一起跳动。 Steve Jobs Thomas Woo 沪漂 胡建人 开发工程师 喜欢编程、造轮子和用轮子 对未知事物充满好奇 喜欢精巧的设计及事物 动漫 名侦探柯南 海贼王 火影忍者 家庭教师 死神 钢之炼金术师 猎人 蜡笔小新 犬夜叉 七龙珠&amp;龙珠超 一拳超人 网球王子 鬼灭之刃…… 电影 钢铁侠 漫威系列… 蝙蝠侠 终结者 成龙大哥相关 周星驰相关 杰森斯坦森相关…… 喜欢动漫和科幻电影，因为动漫和科幻电影可以让人进入现实生活没办法进入的遐想世界，在其中消化不好的情绪，积极的活下去喜欢动漫、电影和编程的童鞋可以一起交流（ps：我电影都是记不住名字的……） 本站文章如无特别声明，均为原创，采用 知识共享署名 4.0 国际许可协议 进行许可，转载请注明来源 本站采用了 Hexo 静态博客框架，主题基于 Icarus 进行修改","link":"/about/index.html"}],"posts":[{"title":"Git操作","text":"记录Git操作的命令和细节 Commandgit pull &amp; git fetchgit fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中；而git pull 则是将远程主机的最新内容拉下来后直接合并，git pull = git fetch + git merge git add 将文件的修改，文件的新建，添加到暂存区 git add . 将文件的修改、文件的删除，添加到暂存区 git add -u 将文件的修改，文件的删除，文件的新建，添加到暂存区 git add -A git commit 撤销commit git reset --soft HEAD^ 添加文件并提交commit git commit -a -m 'message' 修改未提交commit信息 git commit --amend -m git push 推送本地分支到远程仓库 git push origin develop git checkout123456789# 分支切换git checkout -b develop origin/developgit checkout -t origin/develop # --track 快捷方式git checkout develop # 如果需要检出的分支没有重名的则可简化为这样# 还原文件修改git checkout xx.filegit checkout -- xxx.file # 文件与分支同名的情况可加 -- 解决git checkout . # 撤销当前目录的所有文件的修改 git branch123456789101112131415# 查看远程分支git branch -r# 删除本地分支git branch -d a# 强制删除本地分支git branch -D a# 删除远程分支git branch -r -d origin/devgit push origin :dev# 修改分支名称git branch -m dev develop git merge 合并远程分支到本地 git merge origin/beta git stash 暂存代码使用该命令可以将现在的代码保存下来并恢复到最近一次拉取下来的代码状态，可以使用save “last message”可以为暂存的代码添加备注信息 git stash [push -m &quot;last message&quot;] 恢复暂存代码使用该命令可以将最近一次暂存代码取出和当前的代码进行合并 git stash pop 查看暂存代码列表 git stash list 取出指定版本的暂存代码 git stash apply stash@{1} 查看stash的内容和当前内容的差异（-p详细差异） git stash show [-p] git tag 创建 git tag -a v1.9.13 -m &quot;my version 1.9.13&quot; 显示tag信息 git show v1.9.13 提交 git push origin v1.9.13 删除标签 git tag -d v1.9.13 删除本地标签后删除远程仓库标签 git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; rollback12git reset --hard HEAD^git push origin HEAD --force Others 查看文件修改状态git status -s 查看代码作者 12git blame [filename]git blame -L startLineNum, endLineNum 添加远程仓库git remote add origin git@github.com:stormzhang/test.git 生成ssh密匙ssh-keygen -t rsa 添加git用户信息git config --global user.name &quot;smileorigin&quot;git config --global user.email &quot;smileorigin@foxmail.com&quot; 合并指定提交git cherry-pick &lt;id&gt; gitignore本地仓库的文件忽略规则可以在【本地仓库/.git/info/exclude】文件中添加。注意，忽略规则不会提交到共享库中，只对本地有效 工程化git commit风格 build：构建相关 ci：ci 相关 chore：构建过程或辅助工具的变动 docs：文档修改 feat：新功能 fix：修复 bug perf：改进性能的代码 refactor：重构 revert：版本回退 style：格式改动 test：增加测试 git 分支管理参考 源分支 目标分支 源分支描述 源分支从哪个分支切出 develop N/A 基于此分支开发功能，为项目的开发分支，版本迭代应当基于此分支 master master develop 基于此分支发布文件，为项目的线上分支，Hotfix 应当基于此分支 N/A feature/* develop 用于集成功能 develop hotfix/* master 用于热修复补丁 master 配置git 免登录提交1git clone 的时候，记得 clone ssh 的链接 vimdiff123git config --global diff.tool vimdiff # 设置diff工具为 vimdiffgit config --global difftool.prompt falsegit config --global alias.d difftool # 设置别名 git lg配置 – 更合理的 git log 显示1git config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative\" 使用后只要在命令行输入git lg就可以查看到日志，效果比原来的git log好太多了 Git 软件版本升级1234567891011# 卸载旧 gitsudo apt-get autoremove gitsudo apt install make libssl-dev libghc-zlib-dev libcurl4-gnutls-dev libexpat1-dev gettext unzipwget https://www.kernel.org/pub/software/scm/git/git-2.21.0.tar.gztar -xvf git-2.21.0.tar.gzcd git-2.21.0./configuremakesudo make installgit --version Question fatal: unable to find remote helper for 'https' 1ln -s /usr/lib/git-core/git-remote-https /bin/","link":"/git/git/"},{"title":"Windows 右键打开 cmd","text":"Windows 添加右键菜单快捷在当前目录打开 cmd 效果图 操作步骤 在任意位置新建一个文件（只要能粘贴文字的即可，如：.txt）将以下内容粘贴进去，保存好后，修改文件后缀（格式）为.reg，双击打开确认添加注册表，在任意目录下右键菜单都会出现如上图所示的在当前目录下打开具有管理员权限的cmd窗口 12345678910111213141516171819202122232425262728293031323334353637Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas][HKEY_CLASSES_ROOT\\Directory\\shell\\runas]@=\"Open cmd here as Admin\"\"HasLUAShield\"=\"\"[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]@=\"cmd.exe /s /k pushd \\\"%V\\\"\"[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas][HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]@=\"Open cmd here as Admin\"\"HasLUAShield\"=\"\"[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]@=\"cmd.exe /s /k pushd \\\"%V\\\"\"[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas][HKEY_CLASSES_ROOT\\Drive\\shell\\runas]@=\"Open cmd here as Admin\"\"HasLUAShield\"=\"\"[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]@=\"cmd.exe /s /k pushd \\\"%V\\\"\" 修改文中的@=&quot;Open cmd here as Admin&quot;双引号中的文字Open cmd here as Admin，即可修改添加的菜单项的名称 删除添加的菜单，同样的方法新建.reg后缀的文件，粘贴如下内容，双击执行即可 1234567Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\Directory\\shell\\runas] [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] [-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]","link":"/another/windows-right-click-cmd/"},{"title":"Linux SSR","text":"因为一个需求，所以研究了下——Linux终端下如何使用SSR优雅的出国访问优质(恩……)的国外网站，本笔记的实验环境是Center OS，其他Linux发行版本类似 SSR安装SSR 作为懒癌患者首选GitHub上的CharlesScripts项目的安装脚本 1wget https://github.com/the0demiurge/CharlesScripts/raw/master/charles/bin/ssr 将该脚本移至$PATH环境变量包含的目录，如：/usr/local/bin；并修改文件权限为可执行权限 12mv ssr /usr/local/bin/ssrchmod +x /usr/local/bin/ssr 安装 1ssr install 执行命令后会自动安装到：$HOME/.local/share/shadowsocksr 配置SSR 使用命令：ssr config打开配置文件，按照以下类似配置保存即可 12345678910111213141516171819202122232425{ \"server\": \"103.114.161.160\", // 服务器ip \"server_ipv6\": \"::\", \"server_port\": 667, // 服务器端口 \"local_address\": \"127.0.0.1\", \"local_port\": 1080, // 本地端口，记住这个，后续Privoxy将代理这个端口 \"password\": \"ntdtv.com\", // 服务器密码 \"method\": \"AES-256-CFB\", // 加密方式 \"protocol\": \"origin\", // 加密协议 \"protocol_param\": \"\", \"obfs\": \"plain\", // 混淆方式 \"obfs_param\": \"\", \"speed_limit_per_con\": 0, \"speed_limit_per_user\": 0, \"additional_ports\" : {}, // only works under multi-user mode \"additional_ports_only\" : false, // only works under multi-user mode \"timeout\": 120, \"udp_timeout\": 60, \"dns_ipv6\": false, \"connect_verbose_info\": 0, \"redirect\": \"\", \"fast_open\": false} 保存后，可看到自动提示的信息，输出如下类似内容就是配置成功了： 1234567891011121314151617181920212223242526272829[root@sssssssss home]# ssr configIPv6 not support2018-12-21 01:09:09 ERROR shell.py:50 [Errno 2] No such file or directory: '/var/run/shadowsocksr.pid'2018-12-21 01:09:09 ERROR daemon.py:146 not runningIPv6 not support2018-12-21 01:09:09 INFO util.py:85 loading libcrypto from libcrypto.so.10startedTesting Connection...local_port is 1080; if any exceptions orrured, please install jqconnection information:{ \"ip\": \"103.114.161.160\", \"city\": \"Suqian\", \"region\": \"Jiangsu\", \"country\": \"CN\", \"loc\": \"33.9492,118.2960\", \"postal\": \"223800\", \"org\": \"AS40676 Psychz Networks\"}IP : 103.114.161.160地址 : 美国 加利福尼亚州 洛杉矶运营商 : hosteons.com数据二 : 美国 | 新加坡HostEONS私人有限公司(美芝路5001号黄金坊04-01号)美国Psychz数据中心洛杉矶节点数据三 : 美国加利福尼亚洛杉矶URL : http://www.cip.cc/103.114.161.160You may install proxychains4 and configure it properly to test net delay 常用命令 ssr help查看帮助信息 ssr start启动ssr ssr stop关闭ssr ssr restart重启ssr ssr uninstall卸载ssr 安装proxychins4根据上一节末的提示信息(You may install proxychains4 and configure it properly to test net delay)可知没有安装proxychins4所以无法进行延迟测试 克隆proxychins-ng1git clone https://github.com/rofl0r/proxychains-ng.git 安装12345cd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-config 输出信息123456789101112131415161718192021222324252627282930313233343536373839[root@izuf6f5j6kravfwcn9kgtqz home]# git clone https://github.com/rofl0r/proxychains-ng.git正克隆到 'proxychains-ng'...remote: Enumerating objects: 17, done.remote: Counting objects: 100% (17/17), done.remote: Compressing objects: 100% (17/17), done.remote: Total 1211 (delta 6), reused 4 (delta 0), pack-reused 1194接收对象中: 100% (1211/1211), 626.98 KiB | 58.00 KiB/s, done.处理 delta 中: 100% (788/788), done.[root@izuf6f5j6kravfwcn9kgtqz home]# cd proxychains-ng[root@izuf6f5j6kravfwcn9kgtqz proxychains-ng]# ./configure --prefix=/usr --sysconfdir=/etcchecking whether we have GNU-style getservbyname_r() ... yeschecking whether $CC defines __APPLE__ ... nochecking whether $CC defines __FreeBSD__ ... nochecking whether $CC defines __OpenBSD__ ... nochecking whether $CC defines __sun ... nochecking whether we can use -Wl,--no-as-needed ... yeschecking what's the option to use in linker to set library name ... --sonameDone, now run make &amp;&amp; make install[root@izuf6f5j6kravfwcn9kgtqz proxychains-ng]# makecc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/nameinfo.o src/nameinfo.cprintf '#define VERSION \"%s\"\\n' \"$(sh tools/version.sh)\" &gt; src/version.hcc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/version.o src/version.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/core.o src/core.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/common.o src/common.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/libproxychains.o src/libproxychains.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/allocator_thread.o src/allocator_thread.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/ip_type.o src/ip_type.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/hostsreader.o src/hostsreader.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/hash.o src/hash.ccc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/debug.o src/debug.ccc -fPIC -Wl,--no-as-needed -ldl -lpthread -Wl,--soname,libproxychains4.so \\-shared -o libproxychains4.so src/nameinfo.o src/version.o src/core.o src/common.o src/libproxychains.o src/allocator_thread.o src/ip_type.o src/hostsreader.o src/hash.o src/debug.occ -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/main.o src/main.ccc src/main.o src/common.o -o proxychains4[root@izuf6f5j6kravfwcn9kgtqz proxychains-ng]# sudo make install./tools/install.sh -D -m 644 libproxychains4.so /usr/lib/libproxychains4.so./tools/install.sh -D -m 755 proxychains4 /usr/bin/proxychains4[root@izuf6f5j6kravfwcn9kgtqz proxychains-ng]# sudo make install-config./tools/install.sh -D -m 644 src/proxychains.conf /etc/proxychains.conf 修改配置文件1vim /etc/proxychains.conf proxychains默认使用的是9050端口，而我们SSR配置中使用的是1080端口，所以要将配置文件最底部的socks4 127.0.0.1 9050改为socks4 127.0.0.1 1080安装完成后再次运行ssr test即可看到延迟测试信息了 Privoxy安装 Center OS 12yum install -y epel-releaseyum install -y privoxy Debian 1apt-get install -y privoxy PAC模式进行全局代理会大大的影响我们访问国内地址，所以我们使用PAC模式来进行流量代理。根据GFWList(由AutoProxy官方维护)来判断哪些网站被我们的超级安全防御墙（超级ma fan的wall）挡在门外这里我们使用@Otokaze 的shell自动转换脚本来获取GFWList配置 获取脚本1wget https://github.com/SAMZONG/gfwlist2privoxy/raw/master/gfwlist2privoxy 执行1bash gfwlist2privoxy 这里会提示需要输入ip地址及端口，输入你ssr配置的本地地址及端口即可，测试内容如下：1234567[root@izuf6f5j6kravfwcn9kgtqz ~]# bash gfwlist2privoxyproxy(socks5): 127.0.0.1:1080{+forward-override{forward-socks5 127.0.0.1：1080 .}}=================================================================\"cp -af /root/gfw.action /etc/privoxy/\" 后续操作12cp -af gfw.action /etc/privoxy/echo 'actionsfile gfw.action' &gt;&gt; /etc/privoxy/config 设置http、https监听的端口及不监听的端口，Privoxy 默认监听端口是是8118123export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export no_proxy=localhost 只在本次连接会话有效，重新连接服务器后需要重新设置永久有效配置方式：1vim /etc/profile 编辑/etc/profile（Debian则是修改~/.bashrc文件）文件，在文件末尾加上上面的3条export命令重新连接服务器即可 启动服务1systemctl start privoxy.service 测试1curl www.google.com 能看到Google网页的源码就说明穿墙成功了 参考文章 https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr 在Linux终端使用SSR服务实现科学上网 Ubuntu 16.04 ProxyChains4编译安装","link":"/linux/ssr/"},{"title":"LinuxCommand","text":"记录一些常用的 Linux 命令 Debian 安装软件apt-get install package_name——packagename为要安装的软件的包名 升级列表中的软件包的地址apt-get update 升级所有已安装的软件（要先执行apt-get update才能确保软件都更新到最新）apt-get upgrade 确认依赖的软件仓库是不是正确apt-get check 从下载的软件包中清理缓存apt-get clean 卸载软件sudo apt-get remove packageName 自动卸载残留依赖包sudo apt-get autoremove 查看文件内容cat file1 查看一个文件的前2行head -2 file1 查看系统信息cat /proc/version 查看CPU信息cat /proc/cpuinfo、lscpu 重启reboot 注销logout 关机shutdown -h now 返回上一级cd .. 返回上两级cd ../.. 返回上次所在路径cd - 显示工作路径pwd 查看目录中的文件ls 查看目录中的文件ls -F 显示文件和目录的详细资料ls -l 显示隐藏文件ls -a 创建文件夹mkdir name 创建目录树mkdir -p /tmp/dir1/dir2 删除文件rm -f file1 删除文件夹rm -rf dir1 移动文件夹mv dir1 new_dir 复制文件cp file1 file2 重命名mv old.file new.file 复制一个目录下的所有文件到当前工作目录cp dir/* . 修改一个文件或者目录的时间戳touch -t 0712250000 file1 搜索文件和目录find / -name filename 显示已经挂载的分区列表df -h 估算目录占用的空间du -sh dirname 解压zip压缩包unzip file1.zip 解压gz压缩包gunzip file1.gz 解压rar压缩包unrar x file.rar 解压tgz压缩包tar -xzvf *.tar.gz 删除export的变量unset variable_name Center OS命令 查看防火墙状态service firewalld status 关闭防火墙（重启服务器无效）systemctl stop firewalld.service 彻底关闭防火墙systemctl disable firewalld.service 开启防火墙systemctl start firewalld.service 查看激活的连接信息(仅服务进程)netstat -tnl 查看激活的连接信息(仅服务进程，包含端口信息)netstat -tnlp 查看历史命令history","link":"/linux/command/"},{"title":"DynamicTranslate","text":"在日益国际化的现在，英语成为了主流的语言，很多地方，生活和学术上都需要用到英语，很多研究的结果文章也是以英语为主要语言，而现在刚接触技术或者英语的人就很难很快的学好英语，没办法看懂英语内容，而传统的翻译软件存在巨大的局限性，没有办法很快速的进行翻译，一般的输入翻译存在很大的局限性，国内软件又有太多的广告，软件也十分臃肿。因此我们致力于打造一款高效，快速，又界面精美的翻译APP，我们的快捷翻译覆盖99%的操作场景，能让我们告别手动输入查找翻译的复杂过程 部分功能演示视频点击查看演示视频 功能引导界面程序初次安装打开会有操作提示，可以根据提示熟悉程序操作 翻译源切换按钮 点击此按钮可切换有道和百度的翻译源（搜索翻译时使用的翻译提供商） OCR图片转文字按钮 点击此按钮会展开两个小按钮，如右图右下角所示，一个是相机按钮，一个是相册按钮，通过点其中一个按钮来获取图片并进行裁剪后，识别图中文字进行翻译 魔术手势球 通过简单的上、下、左、右滑动手势，长按、单击操作，进行相关功能的调用，集杂多的按钮为一体，简洁高效 在魔术手势球被拖动的过程中，魔术手势球中间的图标会跟随手势的方向变换相关方向的图标。如上拉是打开设置界面，此时小球中的图标就是设置图标 权限引导功能引导完毕后，会弹出权限请求界面，点击同意获取“易译”运行需要使用的权限，例如：易译图片识别文字功能需要使用到的拍照、文件存储器的读写的权限 主界面翻译查询功能 手动输入 在主界面，点击输入框，就可以输入要翻译的内容，点击魔术手势按钮，进行查询，查询过程中魔术收拾按钮会显示进度圈，查询完成后在卡片中会显示翻译结果 点击翻译结果就可以复制到剪切板，点击音标就可以播放单词发音，如果有开启分词模式，长按翻译结果就可调出分词界面，选择需要的内容 查询完翻译后，将魔术手势球向右划就可以将翻译结果添加到记忆本中 语音输入 长按魔术手势球不放即可开始语音输入，此时魔术手势球的图标就会变成语音输入提示图标，放开手指就可结束语音输入，长时间没有声音输入，程序也会自动停止语音输入功能 语音输入结束后，程序会通过讯飞提供的语音技术，将语音转换为文字，自动输入到输入框，此时只需要点击魔术手势球就可以进行翻译了 设置 登陆 本程序为了程序的简洁性，提供了便捷的一键登陆省去了用户的注册和使用成本，非常方便 点击“QQ一键登陆”后如果有安装手机QQ则会自动跳转到快捷登陆界面，如果没有安装手机QQ则会跳转到网页登陆界面，登陆完毕后，将会自动获取用户头像和云端记忆本数据，用户可以自由的选择同步方式，也可以选择不同步 第一次登陆成功后，将会显示用户引导，提示“退出操作” 点击头像后就会有一个翻转效果，翻转为一个叉叉的图标，点击就可进行退出操作，将会显示一个炸裂的效果，程序将自定进行退出操作 登陆成功后，可以进行选择同步方式，不选择则不进行同步，选择后，程序背景波浪将会加速波浪变矮，同步完成后，波浪会恢复正常，提醒同步成功 多彩主题 设置界面右滑即可进入主题设置界面，“易译”内置20种多彩主题，可以随心切换，也可以开启“随机主题”模式，开启后每次进程序都会切换不同的主题 更多设置 在设置界面向右滑动即可进入更多设置 在这里可以进行更多的设置，如：检查版本更新，清空单词发音的缓存的操作 句子词性分析在设置中开启分词模式后，在使用复制翻译或者任何触发翻译（除主界面的输入点击翻译）都会优先触发分词功能。 分词功能是用来帮助用户筛选和排序获得的文字，我们日常生活中，复制的要翻译的内容或者获取的要翻译的内容大都会参杂着一些不需要的文字，传统的做法是粘贴后在一个个删除，而有了分词后，就可以直接选择需要的部分，简单快捷，定位准确，选好后直接点击右下角的搜索图标就会跳转到主界面进行翻译选中文字后，可以点击右上角的图标进行复制左下角的第一个图标可以进行反向选择左下角第二个图标点击后，可以随意拖动文字进行任意排序，点击按钮后按钮会变成打勾按钮，排序好后，点击打勾图标按钮即分词功能覆盖于大部分的程序操作，极大的便利于用户对信息的过滤，快捷的分离信息，分离获取的翻译的内容，值获取想要的部分 手势悬浮球在设置第一页即可找到开启的开关，点击开关后如果程序没有具有展示悬浮球的权限，程序将会自动跳转到系统悬浮窗设置界面，只要打开设置悬浮窗口的开关，返回程序再打开收拾悬浮球的开关即可，打开时会有操作介绍悬浮球是本程序快捷操作的核心，很大程度的辅助了用户的操作 长按悬浮球然后在拖动就可以进行悬浮球的移动 单击就可以进入程序的主界面 下拉可以进行快速的语音输入，图标将会变成“碟片”形式旋转，提示正在收听，当用户不说话时，语音录入将会自动停止，此时如果有打开分词模式将会进入分词模式，如果没有打开分词模式将直接进入主界面进行翻译 下拉两秒不放，即可暂时关闭悬浮球，并在下次打开主界面的时候再次自动打开 向左或者向右拉动，即可打开全局复制功能 复制翻译在设置中打开复制翻译，即可使用复制翻译功能，也可在设置中开启或者关闭复制查词是否只对英语有效，来过滤复制的触发情况在任何界面（除本程序）复制任何要翻译的内容，就会呼出本程序（如果又开启分词模式则进入分词模式，没有开启则直接进入主界面进行翻译） 全局复制通过悬浮球左拉或者右拉手势既可触发有些系统或者软件的界面是无法复制的，所以针对此我们推出了全局复制功能，在大部分场景中都可以实现快捷省心的复制。启动全局复制后，会出现选区，可选择复制的文字周围会出现虚线框，点击即可选中，长按触发翻译功能，为了不遮挡可复制范围，下方的两个按钮是可以任意拖动的，不影响具体功能，选中点击确定即可获取选中的所有文本进入翻译 OCR 基本OCR 在主界面图片选取按钮选取图片后就会进入裁剪界面，选择需要识别的文字的区域点击确定即可自动开始识别 悬浮手势球快捷OCR 在任意界面（除主程序界面），通过上拉手势球就可进入OCR快捷识别功能 开启后会在屏幕上显示3个按钮，3个按钮都是可以随意移动的 点击确定按钮可以开启截取模式，截取全屏，然后你可以选择要翻译的内容进行裁剪，然后调用翻译功能（如果有开启分词模式则先进入分词模式） 点击中间的按钮即可开启全屏标注功能，自定翻译全屏幕的英文，然后以叠层的方式覆盖在原文上 点击叠层内容即可显示OCR识别的文字的原文 长按叠层可开启分词模式，对翻译的内容进行选取和复制，或者再次翻译","link":"/project/dynamic-translate/"},{"title":"七牛图床快速上传工具","text":"这个小软件的开发初衷是，最近在用 Markdown 记笔记发现要弄图片上去很麻烦，一般的步骤至少都是 截图–&gt;保存–&gt;选择图片–&gt;上传–&gt;获取外链，现在可能有一些软件可以直接粘贴，但我还没找到，又懒得找，加上又希望自己能管理这些图片而不是上传到公共图床，所以就想自己写一个，本来是想学点 Python 写的但是写到一半发现很多不熟悉的东西相关的操作方法也没找到就放弃了，就想说一直在练 Android 还没写过 Java 的电脑端程序就想试试，于是就有了现在这个 TC 小工具。 运行环境 需要在安装有JDK(7.0及以上)的电脑，双击打开TC.jar即可使用，目前我自己只有Windows电脑，所以不知道其他平台的能不能用（Java是跨平台。。。？！） 功能 剪切板监听开启剪贴板监听后，当检测到剪切板有新的截图时（系统截图功能或者QQ截图）就会将图片上传到指定的七牛云，并将外链复制到剪切板，粘贴即可，外链已经处理成Markdown的图片格式即![(http://ojrfmxxyi.bkt.clouddn.com/2017%E5%B9%B401%E6%9C%8817%E6%97%A517_13_09_288.png)这种格式，关闭后将不会进行监听和自动上传，所有的数据均只会上传到您设定的七牛云不会和有任何窃取信息行为 上传剪切板图片这是在自己不希望截图的时候直接上传设置的，当使用QQ或者系统自带的截图软件进行截图后，点击此按钮即可手动上传 将本地图片拖进窗口上传本来想实现的是当复制的文件是图片时进行上传，但是没找到比较好的方法，使用循环来进行检测又怕占用资源，所以就使用了折中的方案，直接将图片拖进窗口，并且此功能的一个有点是可以进行批量上传，可以将多张图片拖进窗口进行上传，软件将会将这些图片的链接整合在一起复制到剪切板 其他TC首次运行并链接七牛云时会在所在的路径下创建一个Config文件夹，并在文件夹中创建一个保存信息的文件，以便后面开启软件时直接读取记录，节省反复输入信息的麻烦，可通过软件中的删除配置功能或者手动删除该文件夹或文件即可输入新的信息。使用剪切板上传图片时会先在程序所在目录生成一个图片，上传后会删除，不要再上传过程删除掉。安装完JDK并且配置好环境变量，后重启电脑，启动后双击即可打开该程序。 注意事项我现在只试过QQ和Windows自带的截图功能，其他的截图软件和功能没试过，如果原理都是将图片暂时存储在剪切板则都可以使用，本软件也只在Windows8.1上进行测试通过，没有在其他平台和环境中进行测试，请须知 演示视频地址https://v.youku.com/v_show/id_XMjQ3NTYyNDc5Mg==.html?spm=a2h0w.8278793.2736843.4 关于设置七牛云 Access Key And Secret Key 在七牛云的个人中心–&gt;密匙管理中可以找到 BucketName 进入七牛–&gt;对象存储中，BucketName即你要上传的图片的存储空间的空间名，创建的空间一个要为公开空间 Domain Domain是每个存储空间都有的域名 即图中的默认外链域名 结语因为是第一次写Java电脑端程序，加上自己的Java水平太低，代码很一般，就先不放源码出来了，等感觉可以一点了，会将源码上传，还请见谅。非常感谢您看到这最后面，这就是对我最好的鼓励，smileorigin只是一个初级的小开发者，如本程序有什么问题，本人会积极解决，我将此小工具发出来也只是个尝试，抱着很多用Markdown写博客的人或许会需要的的小期望尝试下，非常感谢您看完这篇介绍文章。","link":"/project/tc/"},{"title":"EffectivePython Advices Record","text":"Recorded something 《EffectivePython》advices notes 不要通过检测长度的方法来判断somelist是否为空不要使用如：if len(somelist) &gt; 0来判断somelist是否为[]或“空值”，而是应该采用if not somelist这种写法来判断，somelist为空值或者None表达式not somelist都将会为True检测子元素somelist[i]也应该使用这种方法Example 123456789101112131415&gt;&gt;&gt; a = None&gt;&gt;&gt; if not a:... print(\"I'm none.\")...I'm none.&gt;&gt;&gt; b = []&gt;&gt;&gt; if not b:... print(\"I'm empty list.\")...I'm empty list.&gt;&gt;&gt; c = {}&gt;&gt;&gt; if not c:... print(\"I'm empty dictionary.\")...I'm empty dictionary. 编写Python程序的时候一定要把编码和解码放在界面最外围来做程序的核心部分应该使用Unicode字符类型（也就是Python3中的str，Python2中的unicode），而且不要对字符编码做任何假设。这种办法可以另程序接受多种类型的文本编码（Latin-1、Shift JIS和Big5），又可以保证输出的文本信息只采用一种编码形式（最好是UTF-8）由于Python的字符类型有别，所以Python代码中经常会出现两种使用场景： 开发者需要原始8位值，这些8位值表示以UTF-8格式或其他编码形式来编码的字符 开发者需要操作没有特定编码形式的Unicode字符所以我们需要编写两个辅助函数，以便在这两种情况之间转换，使得转换后的输入数据能够符合开发者的预期在Python3中，我们需要编写接受str或bytes，并总返回str的方法： 123456def to_str(bytes_or_str): if isinstance(bytes_or_str, bytes): value = bytes_or_str.decode('utf-8') else: value = bytes_or_str return value 另外还需要接受str或bytes，并总是返回bytes的方法 123456def to_bytes(bytes_or_str): if isinstance(bytes_or_str, str): value = bytes_or_str.encode('utf-8') else: value = bytes_or_str return value 用zip函数同时遍历两个迭代器在编写Python代码时，我们通常要面对很多个列表，而这些列表里的对象，可能也是相互关联的。通过列表推导，很容易就能根据某个表达式从源列表推算出一份派生类表 12names = ['Cecilia', 'Lise', 'Marie']letters = [len(n) for n in names] 对于本例中的派生列表和源列表来说，相同索引处的两个元素之间有着关联。如果想平行地迭代这两份列表，那么可根据names源列表的长度来执行循环 123456789101112longest_name = Nonemax_letters = 0for i in range(len(names)): count = letters[i] if count &gt; max_letters: longest_name = names[i] max_letter = countprint(longest_name)&gt;&gt;&gt;Cecilia 上面这段代码的问题在于，整个循环语句看上去很乱。用下标来访问names和letters会使代码不易阅读。用循环下标i来访问数组的写法一共出现了两次。改用enumerate来做可以稍微缓解这个问题。但是仍然不够理想 12345for i, name in enumerate(names): count = letters[i] if count &gt; max_letters: longest_name = names[i] max_letters = count 使用内置的zip函数能够使上述代码变得更加简洁。在Python3中的zip函数，可以把两个或者两个以上的迭代器封装为生成器，以便稍后求值。这种zip生成器，会从每个迭代器中获取该迭代器的下一个值，然后把这些值汇聚成元组。与通过下标来访问多份列表的那种写法相比，这种用zip写出来的代码更加明晰 1234for name, count in zip(names, letters): if count &gt; max_letters: longest_name = name max_letters = count zip存在一个问题，如果两个迭代器的长度不一致，zip会自动提前终止 itertools内置模块中的zip_longest函数可以平行地遍历多个迭代器，而不用在乎它们的长度是否相等 try/except/elsetry/except/else 结构可以清晰地描述出哪些异常会由自己的代码来处理、哪些异常会传播到上一级。如果try块没有发生异常，那么就执行else块。有了这种else块，我们可以尽量缩减try块内的代码量，使其更加易读。例如，要从字符串中加载JSON字典数据，然后返回字典里某个键所对应的值 1234567def load_json(data, key): try: result_dict = json.loads(data) # May raise ValueError except: raise KeyError from e else: return result_dict[key] # May raise KeyError 如果数据不是有效的JSON格式，那么用json.loads解码时，会产生ValueError。这个异常会由except块来捕获并处理。如果能够解码，那么else块里的查找语句就会执行，它会根据键来查出相关的值。查询时若有异常，则该异常会向上传播，因为查询语句并不在刚才那个try块的范围内。这种else子句，会把try/except后面的内容和except本身区分开，使异常的传播行为变得更加清晰 用生成器表达式来改写数据量较大的列表推导式列表推导缺点–在推导过程中，对于输入序列中的每个值来说，可能都要创建仅含一项元素的全新列表。当输入的数据比较少时，不会出现问题，但如果输入的数据非常多，那么可能会消耗大量的内存，并导致程序崩溃例如要读取一份文件并返回每行的字符数。若采用列表推导来做，则需要把文件每一行的长度都保存在内存中。如果这个文件特别大，或者是通过无休止的network socket来读取，那么这种列表推到就会出问题。下面这段列表推到代码，只适合处理少量的输入值 1234value = [len(x) for x in open('/tmp/test_file.txt')]print(value)&gt;&gt;&gt;[2,100,200,43,100] 为了解决此问题，Python提供了生成器表达式，它是对列表推导和生成器的一种泛化。生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器，这个迭代器每次可以根据生成器表达式产生一项数据。把实现列表推到所用的那种写法放在一对括号中，就构成了生成器表达式。下面给出的生成器表达式与刚才的代码等效。二者的区别在于，对于生成器表达式求值的时候，它会立刻返回一个迭代器，而不会深入文件中的内容。以刚才返回的迭代器为参数，逐次调用内置的next函数，即可使其按照生成器表达式来输出下一个值。可以根据自己的需求，多次命令迭代器根据生成器表达式来生成新值，而不用担心内存用量激增 123456it = (len(x) for x in open('/tmp/test_file.txt'))print(next(it))print(next(it))&gt;&gt;&gt;2100 使用生成器表达式还有个好处，就是可以相互组合。下面代码会把刚那个生成器表达式所返回的迭代器用作另一个生成器表达式的输入值。外围的迭代器每次前进时，都会推动内部那个迭代器，这就产生了连锁效应，使得执行循环、评估条件表达式、对接输入和输出等逻辑都组合在一起。这种连锁生成器表达式，可以迅速在Python中执行。如果要吧多种手法组合起来，以操作大批量的输入数据，那最好用生成器表达式来实现。只是要注意：由生成器表达式所返回的那个迭代器是有状态的，用过一轮之后，就不要反复使用了 1234roots = ((x, x**0.5) for x in it)print(next(roots))&gt;&gt;&gt;(12,23) 考虑用生成器来改写直接返回列表的函数如果函数要产生一系列结果，那么最简单的做法就是把这些结果都放在一份列表里，并将其返回给调用者。例如：我们要查出字符串中每个词的首字母在整个字符串里的位置。下面这段代码，用append方法将这些词的首字母索引添加到result列表中，并在函数结束时将其返回给调用者 12345678def index_words(text): result = [] if text: result.append(0) for index, letter in enumerate(text): if letter == ' ': result.append(index + 1) return result 输入一些范例值，以验证该函数能够正常运作： 1234&gt;&gt;&gt; address = 'Four score and seven years age...'&gt;&gt;&gt; result = index_words(address)&gt;&gt;&gt; print(result[:3])[0, 5, 11] 第一个问题是，这个代码写得有点拥挤。每次找到新的结果，都要调用append方法。但我们真正应该强调的，并不是对result.append方法的调用，而是该方法给列表中添加的那个值，也就是index + 1。另外，函数首尾还有一行代码用来创建及返回result列表。于是，在函数主体部分的约130个字符里，重要的大概只有75个 这个函数改用生成器（generator）来写会更好。生成器是使用yield表达式的函数。调用函数时，它并不是真正的运行，而是会返回生成器。每次在这个迭代器上面调用内置的next函数时，迭代器会把生成器推进到下一个yield表达式那里。生成器传给yield的每一个值都会由迭代器返回给调用者 下面的这个生成器函数，会产生和刚才那个函数相同的效果 123456def index_words_iter(text): if text: yield 0 for index, letter in enumerate(text): if letter == ' ': yield index + 1 123result = list(index_words_iter(address))&gt;&gt;&gt; print(result[:3])[0, 5, 11] 这个函数不需要包含域result列表相交互的那些代码，因而看起来比刚才那种写法清晰许多。原来那个result列表中的元素，现在都分别传给yield表达式了。调用该生成器后所返回的迭代器，可以传给内置的list函数，以将其转换为列表 使用None和文档字符串来描述具有动态默认值的参数有时我们想采用一种非静态的类型，来做关键字参数的默认值。例如：在打印日志消息的时候，要把相关事件的记录时间也标注在这条消息中。默认情况下，消息里面所包含的时间，应该是调用log函数那一刻的时间。如果我们以为参数的默认值会在每次执行函数时得到评估，那可能就会写出下面这种代码 12345678&gt;&gt;&gt; def log(message, when=datetime.datetime.now()):... print('%s : %s' % (when, message))&gt;&gt;&gt; log('Hi there!')2018-08-08 09:41:37.025822 : Hi there!&gt;&gt;&gt; time.sleep(1)&gt;&gt;&gt; log('Hi again!')2018-08-08 09:41:37.025822 : Hi again! 两条消息的时间戳是一样的，这是因为datetime.now()只执行了一次，也就是它只在函数定义的时候执行了一次。参数的默认值，会在每个模块加载进来的时候求出，而很多模块都是在程序启动的时候加载的。包含这段代码的模块一旦加载进来参数的默认值也就固定不变了，程序不会再次执行datetime.now()True Example 12345678&gt;&gt;&gt; def log(message, when=None):... when = datetime.datetime.now() if when is None else when... print('%s : %s' % (when, message))... &gt;&gt;&gt; log('Hi there!')2018-08-08 09:48:01.383500 : Hi there!&gt;&gt;&gt; log('Hi again!')2018-08-08 09:48:06.394290 : Hi again! 默认值为字典的错误情况实例 123456789101112131415&gt;&gt;&gt; import json&gt;&gt;&gt; def decode(data, default={}):... try:... return json.loads(data)... except ValueError:... return default... &gt;&gt;&gt; foo = decode('bad data')&gt;&gt;&gt; foo['stuff'] = 5&gt;&gt;&gt; bar = decode('also bad')&gt;&gt;&gt; bar['meep'] = 1&gt;&gt;&gt; print('Foo:', foo)Foo: {'stuff': 5, 'meep': 1}&gt;&gt;&gt; print('Bar:', bar)Bar: {'stuff': 5, 'meep': 1} True Example 12345678910111213141516&gt;&gt;&gt; def decode(data, default=None):... if default is None:... default = {}... try:... return json.loads(data)... except ValueError:... return default... &gt;&gt;&gt; foo = decode('bad data')&gt;&gt;&gt; foo['stuff'] = 5&gt;&gt;&gt; bar = decode('also bad')&gt;&gt;&gt; bar['meep'] = 1&gt;&gt;&gt; print('Foo:', foo)Foo: {'stuff': 5}&gt;&gt;&gt; print('Bar:', bar)Bar: {'meep': 1} 用只能以关键字形式指定的参数来确保代码明晰下面定义的这个safe_division_c函数，带有两个只能以关键字形式来指定的参数。参数列表里的*号，标志着位置参数就此终结，之后那些参数，都只能以关键字形式来指定 1def safe_division_c(number, divisor, *, ignore_overflow=False, ignore_zero_division=False): 现在，我们就不用位置参数的形式来指定关键字参数了 123safe_division_c(1, 10**500, True, False)&gt;&gt;&gt;TypeError: safe_division_c() takes 2 positional arguments but 4 were given 关键字参数依然可以用关键字的形式来指定，如果不指定，也依然会采用默认值 123456safe_division_c(1, 0, ignore_zero_division=True) # OKtry: safe_division_c(1, 0)except ZeroDivisionError: pass # Excepted 使用内置算法与数据结构如果Python程序要处理的数量比较可观，那么代码的执行速度会受到复杂算法拖累。然而这并不能证明Python是一门执行速度很低的语言，因为这种情况很可能是算法和数据结构选择不佳导致的幸运的是Python的标准程序库里面，内置了各种算法与数据结构，以供开发者使用。这些常见的算法与数据结构，不仅执行速度比较快，而且还可以简化编程工作。其中某些实用工具，是很难由开发者自己正确实现出来的。所以，我们应该直接使用这些Python自带的功能，而不要重新去实现它们，以节省时间和精力 双向队列collections模块中的deque类，是一种双向队列（double-ended queue，双端队列）。从该队列的头部或者尾部插入或移除一个元素，只需要消耗常数级别的时间，这一特性使得它非常适合用来表示先进先出队列。内置的list类型，也可以像队列那样，按照一定的顺序来存放元素。从list尾部插入或者移除元素，也仅仅需要常熟级别的时间。但是，从list头部插入或者移除元素，却会耗费线性级别的时间，这与deque的常数级别时间相比，要慢得多 1234567891011121314151617181920from collections import dequefrom time import timestart = time()fifo = deque()# Producterfifo.extend([i for i in range(200000)])# Consumerwhile len(fifo) &gt; 0: x = fifo.popleft()end = time()print('deque: {}'.format(end-start))start = time()l = []l.extend([i for i in range(200000)])while len(l) &gt; 0: x = l.pop(0)end = time()print('list: {}'.format(end-start)) 123# 可看到在20万级数据下一直移除第一个元素双向队列的效率要高得非常多deque: 0.08118391036987305list: 4.417634010314941 有序字典标准字典是无序的。也就是说在拥有相同键值对的两个dict上面迭代，可能会出现不同的迭代顺序。标准的字典之所以会出现这种奇怪的现象，是由其快速哈希表（fast hash table）的实现方式导致的collections模块中的OrderedDict类，是一种特殊的字典，它能按照键的插入顺序，来保存键值对在字典中的次序。在OrderedDict上面根据键来迭代，其行为是确定的。这种确定的行为，可以极大地简化测试与调试工作 1234567891011from collections import OrderedDict a = OrderedDict()a['foo'] = 1a['bar'] = 2b = OrderedDict()b['foo'] = 'red'b['bar'] = 'blue'for value1, value2 in zip(a.values(), b.values()): print(value1, value2) 带有默认值的字典字典可以用来保存一些统计数据。但是，由于字典里面未必有我们要查询的那个键，所以在用字典保存计数器的时候，就必须用稍微麻烦一些的方式，才能够实现这种简单的功能 12345stats = {}key = 'my_counter'if key not in stats: stats[key] = 0stats[key] += 1 我们可以用collections模块中的defaultdict类来简化上述代码。如果字典中没有待访问的键，那么它就会把某个默认值与这个键自动关联起来。于是，我们只要提供返回默认值的函数即可，字典会调用该函数为每一个默认的键指定默认值 1234567from collections import defaultdictdict = defaultdict(int)print(dict['a'])# out0 堆队列堆（heap）是一种数据结构，很适合用来实现优先级队列。heapq模块提供了heappush、heappop和nsmallest等一些函数，能够在标准的list类型之中创建堆结构各种优先级的元素，都可以按任意顺序插入堆中 1234567891011a = []heapq.heappush(a, 5)heapq.heappush(a, 3)heapq.heappush(a, 7)heapq.heappush(a, 4)print('Before: ', a)# 使用sort后依然能保持堆的结构，但是添加reverse后就不能保持堆结构了# a.sort()print('After； ', a)# 按照优先级弹出元素的，数值越小优先级越大print(heapq.heappop(a), heapq.heappop(a), heapq.heappop(a), heapq.heappop(a)) 二分查找在list上面使用index方法来搜索某个元素，所耗的时间会与列表的长度成线性比例。 12x = list(range(10**6))i = x.index(991234) bisect模块中的bisect_left等函数，提供了高效的二分折半搜索算法，能够在一系列排好顺序的元素之中搜寻某个值。由bisect_left函数所返回的索引，表示待搜寻的值在序列中的插入点（将该值插在此处，能够使序列依然保持有序） 1i= bisect_left(x, 991234) 二分搜算法的复杂度，是对数级别的。这就意味着，用bisect来搜索包含一百个元素的列表，与用index来搜索包含14个元素的列表，所耗费的时间差不多。由此可见，这种对数级别的算法，要比线性级别的算法快很多 123456789101112131415161718from bisect import bisect_leftfrom time import timea = [i for i in range(10000)]start = time()bisect_left(a, 9000)end = time()print('bisect: {}'.format(end - start))start = time()a.index(9000)end = time()print('list: {}'.format(end - start))# 运行结果bisect: 1.3828277587890625e-05list: 0.000225067138671875 通过运行结果显而易见，binsect的搜索效率远大于index的搜索效率","link":"/python/advices/"},{"title":"Vim","text":"记录一些常用的 vim 命令 帮助文档 vimtutor命令行直接运行，非vim编辑器内命令 :hvim内部命令 过渡阶段 :set mouse=a设置鼠标可区域选择，跟普通的编辑器一样可以进行拖选 基本操作打开/切换文件 命令 功能 :e file_name 、:o file_name 打开文件 :args file_name 如果使用vim file1 file2 [filen]命令打开多个文件，就可以使用:args file_name命令在打开的文件之间切换 :buffers、:ls、:files 查看缓冲区中的文件列表 :bnext 切换到下一个缓冲区文件 :bprevious、bpre 切换到上一个缓冲区文件 :bfirst 切换到第一个缓冲区文件 :blast 切换到最后一个缓冲区文件 :bdelete file_name 删除缓冲区文件 :badd file_name 添加文件到缓冲区 &lt;Ctrl&gt; + z 回到shell（最小化vim） fg（shell中命令） 在shell中输入fg即可回到最小化的vim中去 退出/保存 命令 功能 :w 保存 :w! 强制保存，不退出vim :q 退出 :q! 强制退出不保存 :wq、ZZ 保存并退出 :wq! 强制保存，并退出 :w file 将修改另存到file中，不退出vim :e! 放弃所有修改，从上次保存文件开始再编辑命令历史 编辑 命令 功能 i/I 编辑 esc 退出编辑模式 u 撤销操作 &lt;Ctrl&gt; + r 重做（恢复被撤销的动作） cc 、S 清空当前行并进入编辑模式 s 删除当前字符并进入编辑模式 r 替换当前字符（替换后不进入编辑模式） R 持续替换字符（不进入编辑模式），替换一个光标自动移到下一个 [&lt;Shift&gt; +] v 可视化多选，&lt;Shift&gt; + v的话是行选 &lt;ctrl&gt; + v 可视化列选 . 重复上次操作 set filetype? 显示文件的filetype &lt;Ctrl&gt; + a 加1 &lt;crtl&gt; + x 减1 排版 命令 功能 =- 格式化当前行代码 gg=G 格式化所有代码 :ce 居中 :le 居左 :re 局右 &gt;&gt; 向右缩进 &lt;&lt; 向左缩进 删除 命令 功能 x 删除当前字符 X 删除当前字符的前一个字符 dd 删除当前行 D /n$ 删除当前字符至行尾 d^ 删除当前字符至行首 dG 删除包含当前行及之后的全部行 cc 清空当前行 C 清空当前字符到行尾的字符 代码补全 命令 代码 &lt;Ctrl&gt; + p 往前搜索补全 &lt;Ctrl&gt; + n 往后搜索补全 &lt;Ctrl&gt; + e 取消补全 &lt;Ctrl&gt; + y 确定补全 移动 命令 功能 gg 跳转到首行 G 跳转到尾行 :n、nG 跳转到第n行 o 在下一行插入 O 在上一行插入 w、W 移动到下一个单词开头 b、B 移动到上一个单词开头 e、E 移动到下一个单词结尾 { 下一段落 } 上一段落 M 跳转到文件内容的中部 H 跳转到文件内容的顶部 L 跳转到文件内容的底部 &lt;Ctrl&gt; + f 下一页 &lt;Ctrl&gt; + b 上一页 '0 返回上一次操作的位置 &lt;Ctrl&gt; + o 移动光标到上一个历史编辑位置 &lt;Ctrl&gt; + i、tab 移动光标到下一个历史编辑位置 gn 移动到选中元素结尾 复制/粘贴 命令 功能 y 复制 p 粘贴到下部 P 粘贴到上部 x、X 剪切 高端点的操作骚操作 命令 功能 vim -d file1 file2 对比文件不同之处 拖动功能 命令 功能 zz 将当前行定位到屏幕中间 zb 将当前行定位到屏幕底部 zt 将当前行定位到屏幕顶部 代码折叠 命令 功能 zf 创建折叠 zo 打开折叠 zc 关闭折叠 :mkview / :loadview 保存，载入折叠 窗口管理 命令 功能 :split [file_name] 、:sp [file_name] 水平分割 :vsplit [file_name]、:vs [file_name] 垂直分割 &lt;Ctrl&gt; + w + h 将焦点移动到左边窗口 &lt;Ctrl&gt; + w + j 将焦点移动到下方窗口 &lt;Ctrl&gt; + w + k 将焦点移动到上方窗口 &lt;Ctrl&gt; + w + l 将焦点移动到右边窗口 更详细的教程：【vim】分割窗口、标签页与Quickfix窗口 Tab操作 命令 功能 :tabnew [++opt选项] ［＋cmd］ 文件 创建指定文件的新tab :tabc 关闭当前的tab :tabo 关闭其他的所有tab :tabs 查看所有打开的tab :tabp 前一个tab :tabn 后一个tab 转换文件编码和格式 命令 功能 :set fileformat unix dos mas 让换行符自由切换 :set fileencodings 检测打开文档编码的顺序，一般设置为utf-8、cp936 :set fileencoding 保存文档的编码，一般为utf-8 :set encoding vim本身界面的编码，一般和文档无关 搜索 命令 功能 f / F 当前行搜索，til，正向 / 反向 t / T 当前行搜索，until，正向 / 反向 ;、, 重复当前行搜索 /、? 当前文件搜索，向上搜索 / 向下搜索 :grep -r / :!grep -r 跨文件搜索 n 下一个匹配内容 N 上一个匹配内容 替换指定字符 :s/target/replace[/g] target：要被替换的内容 replace：替换的内容 可选/g：表示替换当前行所有的需要被替换的内容，如不加这个参数则替换当前行第一个需要被替换的内容 Example： : s/a/b，将当前行的a替换为b : s/a/b/g，将当前行所有的a替换为b :n，$s/target/replace[/g] n为数字表示从第n行开始到最后一行，当n为.时表示从当前行开始 target：要被替换的内容 replace：替换的内容 可选/g：表示替换每一行所有需要被替换的内容，如不添加则替换每一行的第一个需要被替换的内容 Example： : 2, $s/a/b：替换从第2行开始到最后一行的每一行的第一个a为b : 2, $s/a/b/g：替换从第2行开始到最后一行的每一行的所有a为b : ., $s/a/b：替换从当前行开始到最后一行的每一行的第一个a为b 插件使用（在安装的前提下）NERDTree 命令 功能 o 打开/关闭文件或目录 t 在新标签页中打开 T 在后台标签页打开 ! 执行此文件 p 到上层目录 P 到根目录 K 到第一个节点 J 到最后一个节点 u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作） ? 帮助，再按一下关闭 q 关闭 r 刷新列表 i 水平分屏 s 垂直分屏 vim-commentary 快捷键 功能 gcc 注释当前行（普通模式下） gc 注释当前选中内容（可视多选模式下） gcap 注释当前所在段落 gcu 注释上一次注释的部分 gcgc 取消一组相邻的注释 One more thing 命令 功能 q: 查看在vim中使用的历史命令 参考文章 vim-vide 【vim】分割窗口、标签页与Quickfix窗口 vim 树形目录插件NERDTree安装及简单用法 https://github.com/jaywcjlove/vim-web","link":"/linux/vim/"},{"title":"Center OS Django部署","text":"Center OS 部署 Django 程序，使用 Nginx + uWsgi + Supervisor Python3 环境安装 安装可能使用到的依赖 yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel 从Python官网找到需要的Python版本的下载路径，使用wget下载到服务器 这里以Python3.6.7为例：https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz 下载到服务器命令：wget https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz 解压tgz压缩包 tar -zxvf Python-3.6.7.tgz 解压完可以在当前目录下看到Python-3.6.7的目录 把Python移到 /usr/local 下 mv Python-3.6.7 /usr/local 进入Python-3.6.7目录 cd /usr/local/Python-3.6.7 配置 ./configure 编译 make 安装 make install 创建软链接（以便在全局调用） ln -s /usr/local/bin/python3.6 /usr/bin/python3 查看是否安装成功python3 -V 将项目传到到服务器这里我们使用Git来操作，我们把项目传到如：Github或Coding等代码仓库，然后使用Git克隆到服务器。这样每次项目更新了只要将代码上传到仓库，在到服务器将代码拉下来就可以实现代码更新了 项目配置 记得在项目的settings.py中添加以下配置 12345DEBUG = FalseALLOWED_HOSTS = ['你的公网ip(不带端口号)'] # 如果不配置服务器的IP地址将导致外网无法访问，或者使用['*']代表授权全部STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, 'static') 安装Git yum install git 克隆项目到服务器 git clone http://xxxxxx.com，将http://xxxxxx.com换成自己仓库的地址 拉取更新的代码 git pull 更多 更多的Git命令可以查看我另一篇文章：https://smileorigin.site/2017/10/18/Git/Git/ 使用Virtualenv来创建虚拟环境为每一个Django项目都创建一个虚拟环境可以使每个项目的依赖包都互不影响，也不会污染全局环境，其他使用和信息可以查看我的另一篇文章–https://smileorigin.site/2018/08/06/Python/Virtualenv/ 更新pip pip3 install --upgrade pip 安装Virtualenv pip3 install virtualenv 进入项目所在文件夹 假设我们项目文件夹在当前目录且名称为server cd server 创建虚拟环境 在当前文件夹下创建一个名为venv的虚拟环境 virtualenv venv 激活虚拟环境 source venv/bin/activate 可以看到在root之前多了个(venv)，说明激活虚拟环境成功了 使用requirements.txt文件安装依赖包 如果有使用pip freeze &gt;requirements.txt在本地项目导出项目的所有依赖包，则可以通过该命令进行快速安装依赖包，没有的话就手动使用pip安装项目需要的依赖包 pip install -r requirements.txt 安装配置uWsgi 安装 pip install uwsgi 测试uwsgi vim test.py 填写以下内容 123def application(env, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'Hello world'] # Python3 保存后，执行指令进行测试：uwsgi --http 127.0.0.1:8000 --wsgi-file test.py 如果执行成功，则会有以下类似信息： 打开另一个命令行窗口，输入以下命令进行测试：curl 127.0.0.1:8000 如果提示以下信息则表示测试页面运行成功： 可以看到截图有显示：Hello world 新建uwsgi配置文件 vim uwsgi.ini 可以按照以下模板进行填写 1234567891011121314151617181920212223242526272829303132[uwsgi]# 我的项目目录chdir = /root/server# 指定项目的applicationmodule = imageAnalyze.wsgi# 进程个数workers = 5#pid文件保存路径pidfile = /root/server/uwsgi/uwsgi.pid# 指定IP端口http = 127.0.0.1:8000# 指定静态文件static-map = /static=/root/server/static# 启动uwsgi的用户名和用户组uid = rootgid = root# 启用主进程master = true# 自动移除unix Socket和pid文件当服务停止的时候vacuum = true# 序列化接受的内容，如果可能的话thunder-lock = true# 启用线程enable-threads = true# 设置自中断时间harakiri = 30# 设置缓冲post-buffering = 4096# 设置日志目录daemonize = /root/server/uwsgi/uwsgi.log# 指定sock的文件路径socket = /root/server/uwsgi/uwsgi.sock 新建配置文件中的指定文件夹 如果不创建可能导致以配置文件启动uwsgi报文件夹不存在的错误 mkdir uwsgi 创建static文件夹 mkdir static 收集项目静态文件 python manage.py collectstatic 收集成功会提示收集的文件数 以配置文件的形式启动uwsgi uwsgi --ini uwsgi.ini 如果启动成功，则有以下类似提示 使用netstat -tnlp命令可以查看在有哪些端口是运行的，可以看到uwsgi运行在127.0.0.1:8000 关闭uwsgi --stop uwsgi/uwsgi.pid 安装配置Nginx记得在配置Nginx的时候如果使用的是阿里云服务器，要让外部使用的端口要先在阿里云服务器的安全组中打开，否则会不能访问 查找要安装的Nginx的包链接 http://nginx.org/packages/centos/7/x86_64/RPMS/ 安装 rpm -ivh http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.14.1-1.el7_4.ngx.x86_64.rpm 配置Django项目的Nginx配置文件 cd /etc/nginx/conf.d vim server.conf，创建你项目的Nginx的配置文件，把server换成任意名字（/etc/nginx/nginx.conf文件的最后一行是include /etc/nginx/conf.d/*.conf;会加载/etc/nginx/conf.d文件夹下的所有后缀为.conf的配置文件，所以只要在这个目录下创建后缀为.conf的配置文件并配置相关内容，Nginx就会自动帮我们加载了，不需要额外的处理） 123456789101112131415161718server{ listen 80; # 监听的端口 server_name cookbook.aicircle.site; server_name www.cookbook.aicircle.site # 使外部可通过www.cookbook.aicircle.site进行访问 #当请求这些server name的时候，nginx才会做反向代理，0.0.0.0是指全部 location / { proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # location 顾名思义，定位，就是当访问 / 的时候，nginx会将请求转给本地的8080&gt;端口，而后面的设置都是&gt;一些基本的配置，可以直接用 location /static { alias /root/server/static; } # 这个就是配置静态文件的地方，要用绝对地址，对应最开始的目录形式，假设project就在/home下面，那么这&gt;样配置就可以的了，还有个前提是，你在开发的时候，采取了django的建议，每个app的静态文件都用多了一层app_name的文件夹来包住。} 查看Nginx状态 systemctl status nginx，如果Nginx是启动的则会有以下类似提示： 测试Nginx配置文件是否有误 nginx -t，如果有以下类似提示，则配置文件没错 启动Nginx systemctl start nginx 测试是否启动成功 curl http://127.0.0.1:80，如果Nginx启动成功，则会显示以下类似内容 设置开机自启 systemctl enable nginx，如果设置成功则会有类似提示信息 关闭Nginx systemctl stop nginx 重启Nginxsystemctl restart nginx 使用Supervisor来管理进程 Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去，就可以实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息，可以选择是否重新启动程序或报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。 安装 安装我们使用Center OS自带的Python2来安装，Supervisor不支持Python3，打开另一个命令窗口使用以下命令安装 pip2 install supervisor 设置配置文件 vim supervisord.conf，在任意你想要的位置创建配置文件，根据说明将以下参数改为自己的配置，保存 123456789[program:server]command=/root/server/venv/bin/uwsgi --ini /root/server/uwsgi.inidirectory=/root/server startsecs=1 stopwaitsecs=1 autostart=true autorestart=true [supervisord][supervisorctl] program:server：指定程序名称，server为自定义程序名称 command：启动程序的命令，这里是调用虚拟环境内的uwsgi根据配置文件/root/server/uwsgi.ini启动Django程序 directory：项目所在的文件夹 startsecs：启动延迟 stopwaitsecs：关闭延迟 autostart：是否自动启动 autorestart：是否自动重启 启动Supervisor supervisord是服务端，supervisorctl是客户端 supervisord -c supervisord.conf，如果surpervisord.conf不在当前文件夹则需要其绝对路径（如：/etc/xx/supervisord.conf） 重启supervisor service supervisord restart 启动进程 supervisorctl -c supervisord.conf start server 重启进程 supervisorctl -c supervisord.conf restart server 关闭进程 supervisorctl -c supervisord.conf stop server 启动所有进程 supervisorctl start all 关闭所有进程 supervisorctl stop all 查看所有进程的状态supervisorctl status 查看Supervisor的进程信息ps -ef | grep supervisord 错误解决方案 如果以上都配置好了，发现进入网站静态文件无法正常加载，请确认你的项目是不是在/root文件夹下，如果是的话则在修改root目录的权限 chmod -R 755 root 修改完后重启Nginx服务器重新访问网站即可 无法访问服务器（博主这边用的是阿里云服务器，默认防火墙是关闭的） 检查服务器防火墙是否将用到的端口都设为白名单 如果是阿里云服务器，检查安全组是否添加用到的端口为入方向白名单 参考文章 超详细的django1.8处理centos下nginx上处理静态文件步骤！ CentOS 6.9/7通过yum安装指定版本的Nginx Django部署(Nginx) 结合Nginx+uWsgi部署Django项目","link":"/python/django-deploy/"},{"title":"HexoBlogUtils","text":"正常我们要同步博客内容时都需要先打开命令窗口（Windows），然后调转到博客目录，然后输入hexo命令清除之前生成的缓存，然后生成静态文件，最后在部署到repository,很繁琐，这时候如果有个图标点击几下就部署到respository多舒服。。。所以就心血来潮。。。嗯。。。PS：脚本只有在windows 10下1080p分辨率屏幕的电脑测试过，Python版本为3.6.3 Screen capture脚本运行后会打开一个界面和一个命令行窗口 Function Generator 执行hexo clean和hexo g，清理之前生成的静态文件再重新生成静态文件 Deploy 执行hexo d，将生成的静态文件部署到云端 GeneratorAndDeploy 直接自动执行前面两个命令，清理静态文件–&gt;重新生成静态文件–&gt;部署到云端 Server 执行hexo s，启动本地模拟（本地预览博客），默认端口为博客配置设置的，没有设置则为：localhost:4000 PS:使用该按钮之前记得先使用Gnerator按钮 ServerWithCustomPort 如果默认端口被占用，则可在下面的输入另外的端口，端口位4位数字，然后点击ServerWithCustomPort即可开始自定义端口的本地模拟 PS:使用该按钮之前记得先使用Gnerator按钮 最后一个表情按钮 你猜 Using（Windows10） 安装Python3.6.3 点击跳转到官网下载 安装 下载完，一路点击安装即可，最后的完成界面有个选项将python的目录添加到PATH环境变量记得勾选 获取脚本 下载脚本（密码：s3r2）或者将下面的脚本内容复制，然后新建一个.py结尾的文件保存进去即可 执行脚本 右键脚本–&gt;选择打开方式–&gt;选择其他应用–&gt;找到Python的安装目录，选择python.exe双击即可，选定打开方式后记勾选设置为默认打开方式，下次直接双击打开即可。PS：脚本要放在博客目录里才可使用，创建一个脚本的快捷方式到桌面就不用每次都到博客目录运行脚本了 注意 本脚本没有使用子线程去执行耗时操作，所以在执行一项操作时不要再点击其他按钮，不然windows会提示程序无响应可能导致脚本退出，请等待DOS窗口提示操作完成，或者是按下的按钮浮起来界面显示正常在进行其他操作 使用Server或者ServerWithCustomPort功能时，要退出本地模拟只要点击DOS窗口按CTRL+c快捷键组合就会提示是否退出，输入y即可退出，这时候会发现程序界面按钮恢复默认状态，可以继续进行其他操作，重新开启本地模拟或者部署等 Script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#!/usr/bin/env python3# encoding: utf-8'''@author: smileorigin@license: (C) Copyright 2017@contact: smileorigin@foxmail.com@file: hexo_utils.py@time: 12/3/2017 7:02 PM@desc:'''# importimport osfrom tkinter import *from tkinter import messageboxclass MainView(Frame): bg = 'white' bt_bg = '#E91E63' text_color = '#fff' about_msg = 'Author: smileorigin\\nBlog: smileorigin.site\\nEmail: smileorigin@foxmail.com' def __init__(self, generatorCallback, deployCallback, serverCallback, serverCustomPortCallback, generatorAndDeployCallback, master=None): Frame.__init__(self, master, bg=self.bg) # expand扩展frame背景充满整窗口 self.pack(expand=YES, fill='both') self.createWidgets(generatorCallback, deployCallback, serverCallback, serverCustomPortCallback, generatorAndDeployCallback) def createWidgets(self, generatorCallback, deployCallback, serverCallback, serverCustomPortCallback, generatorAndDeployCallback): # four function button self.generator_bt = Button(self, command=generatorCallback, text='Generator', width=20, bg=self.bt_bg, fg=self.text_color) self.generator_bt.pack(pady=10, padx=20) self.deploy_bt = Button(self, command=deployCallback, text='Deploy', width=20, bg=self.bt_bg, fg=self.text_color) self.deploy_bt.pack() self.generator_and_deploy_bt = Button(self, command=generatorAndDeployCallback, text='GeneratorAndDeploy', width=20, bg=self.bt_bg, fg=self.text_color) self.generator_and_deploy_bt.pack(pady=10) self.server_bt = Button(self, command=serverCallback, text='Server', width=20, bg=self.bt_bg, fg=self.text_color) self.server_bt.pack() self.server_custom_port = Button(self, command=serverCustomPortCallback, text='ServerWithCustomPort', width=20, bg=self.bt_bg, fg=self.text_color) self.server_custom_port.pack(pady=8) self.custom_port_label = Label(self, text=\"Port:\", bg=self.bg) self.custom_port_label.pack(fill='x') hint = StringVar() hint.set('5000') self.custom_port_entry = Entry(self, textvariable=hint, bg=self.bg) self.custom_port_entry.pack() self.about_bt = Button(self, text='(⓿_⓿)', command=self.showMessage, bg=self.bt_bg, fg=self.text_color) self.about_bt.pack(pady=10) def showMessage(self): messagebox.showinfo('About', self.about_msg)# --------------------------------------------------------------------------------------------------# constant values# --------------------------------------------------------------------------------------------------# cleancmd_clean = 'hexo clean'# generatorcmd_generator = 'hexo g'# deploycmd_deploy = 'hexo d'# servercmd_server = 'hexo s'# windows width heightwidth = 230height = 280# starstar = '*'# star numstar_num = 84# icon path# icon_path = '\\\\favicon.ico'# outgenerator_start_text = ' generator start 'generator_done_text = ' generator done 'deploy_start_text = ' deploy start 'deploy_done_text = ' deploy done 'server_start_text = ' server start 'server_done_text = ' server done'welcome_text = ' welcome '# --------------------------------------------------------------------------------------------------# method# --------------------------------------------------------------------------------------------------# server with another port# port string what's your port do you want to serverdef serverWithAnotherPort(port): return cmd_server + ' -p ' + portdef executeCommand(cmd): os.system(command=cmd)def regexFourNum(str): p = re.compile('^[0-9]{4}') return p.match(str)def printStar(num): print(star * num)def printStarNotEnter(num): print(star * num, end='')def printStringWithStar(num, string): printStar(star_num) string_len = len(string) half_star_num = (int)((num - string_len) / 2) remainder = num - half_star_num * 2 - string_len printStarNotEnter(half_star_num + remainder) print(string, end='') printStar(half_star_num) printStar(star_num)def generatorCallback(): printStringWithStar(star_num, generator_start_text) executeCommand(cmd_clean) executeCommand(cmd_generator) printStringWithStar(star_num, generator_done_text)def deployCallback(): printStringWithStar(star_num, deploy_start_text) executeCommand(cmd_deploy) printStringWithStar(star_num, deploy_done_text)def serverCallback(): printStringWithStar(star_num, server_start_text) try: executeCommand(cmd_server) except KeyboardInterrupt: printStringWithStar(star_num, server_done_text)def serverCustomPortCallback(): custom_port = str(main_view.custom_port_entry.get()) if custom_port: # port: just 4 number if regexFourNum and custom_port.__len__() == 4: printStringWithStar(star_num, server_start_text) try: executeCommand(serverWithAnotherPort(custom_port)) except KeyboardInterrupt: printStringWithStar(star_num, server_done_text) else: messagebox.showinfo('Input error', 'Port needs 4 digits.Example:5000') else: # error hint input port messagebox.showinfo('Error', 'Please input port.Example:5000')def generatorAndDeployCallback(): generatorCallback() deployCallback()# --------------------------------------------------------------------------------------------------# run code# --------------------------------------------------------------------------------------------------printStringWithStar(star_num, welcome_text)root = Tk()main_view = MainView(generatorCallback, deployCallback, serverCallback, serverCustomPortCallback, generatorAndDeployCallback, master=root)root.title(\"\")root.resizable(0, 0)size = '{}x{}+{}+{}'.format( width, height, (int)((root.winfo_screenwidth() - width) / 2), (int)((root.winfo_screenheight() - height) / 2))root.geometry(size)# root.iconbitmap(sys.path[0] + icon_path)root.mainloop()","link":"/project/hexo-blog-utils/"},{"title":"Less common Python knowledge","text":"Something unknow or less common Python knowledge set集合（Set）是一个无序不重复元素的序列，每个元素只会出现一次。当集合中的项目存在与否比起次序或其出现次数更加重要时，我们就会使用集合 123parame = {value01,value02,...}或者set(value) 通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等 1234567891011121314151617fruit = {'apple', 'banana', 'orange'}color = {'yellow', 'blue', 'green'}print('apple' in fruit)print('green' in color)color_copy = color.copy()print('color is',color)print('copy color is', color_copy)# remove 'green',add pinkcolor_copy.remove('green')color_copy.add('pink')print('remove greeen and add pink to color_copy')print('color is',color)print('copy color is', color_copy)print(color &amp; color_copy)print(color | color_copy) Output: 123456789TrueTruecolor is {'yellow', 'green', 'blue'}copy color is {'yellow', 'green', 'blue'}remove greeen and add pink to color_copycolor is {'yellow', 'green', 'blue'}copy color is {'yellow', 'pink', 'blue'}{'yellow', 'blue'}{'yellow', 'green', 'pink', 'blue'} text[::-1]Example 123def reverse(text): return text[::-1]print(reverse('abcdefg')) Output 1gfedcba PicklePython 提供了一个叫作 Pickle 的标准模块，通过它你可以将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（Persistently）存储对象Example 123456789101112131415161718192021import pickle# 我们存储相关对象的文件的名称shoplistfile = 'shoplist.data'# 我们需要购买的物品清单shoplist = ['apple', 'mango', 'carrot']# 准备写入文件f = open(shoplistfile, 'wb')# 存储对象至文件--封装（Pickling）pickle.dump(shoplist, f)f.close()# 清除shoplist变量del shoplist# 重新打开存储文件f = open(shoplistfile, 'rb')# 从文件中载入对象--拆封（Unpickling）storedlist = pickle.load(f)print(storedlist) Output 1['apple', 'mango', 'carrot'] VarArgs Parameters有时你可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通过使用星号来实现当我们声明一个诸如 *param 的星号参数时，从此处开始直到结束的所有位置参数（Positional Arguments）都将被收集并汇集成一个称为“param”的元组（Tuple）类似地，当我们声明一个诸如 **param 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个名为 param 的字典（Dictionary）Example 1234567891011def total(a=5, *numbers, **phonebook): print('a', a) #遍历元组中的所有项目 for single_item in numbers: print('single_item', single_item) #遍历字典中的所有项目 for first_part, second_part in phonebook.items(): print(first_part,second_part) print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560)) Output 12345678a 10single_item 1single_item 2single_item 3Inge 1560John 2231Jack 1123None DocStringsPython 有一个甚是优美的功能称作文档字符串（Documentation Strings），在称呼它时通常会使用另一个短一些的名docstrings。DocStrings 是一款你应当使用的重要工具，它能够帮助你更好地记录程序并让其更加易于理解Example 12345678910111213def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" passprint(print.__doc__) Output 12345678print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)Prints the values to a stream, or to sys.stdout by default.Optional keyword arguments:file: a file-like object (stream); defaults to the current sys.stdout.sep: string inserted between values, default a space.end: string appended after the last value, default a newline.flush: whether to forcibly flush the stream. enumerate()函数enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中语法 enumerate(sequence, [start=0]) 参数 sequence 一个序列、迭代器或者其他支持迭代的对象 start 下标起始位置 返回值返回enumerate(枚举)对象 Example 12345&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']&gt;&gt;&gt; list(enumerate(seasons))&gt;[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始&gt;[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 1234567&gt;&gt;&gt;seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq): ... print(i, seq[i]) ... 0 one1 two2 three all()all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False元素除了是 0、空、FALSE 外都算 TRUE。函数等价于： 12345def all(iterable): for element in iterable: if not element: return False return True 语法 all(iterable) 参数iterable — 元组或列表 返回值如果iterable的所有元素不为0、False或者iterable为空，all(iterable)返回True，否则返回False注意：空元组、空列表返回值为True，这里要特别注意 filter()filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中语法 filter(function, iterable) 参数 function – 判断函数 iterable – 可迭代对象 返回值返回筛选完的列表 Example 12345# 过滤出列表中的所有奇数def is_odd(n): return n % 2 == 1 newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) print(list(newlist)) Output 1[1, 3, 5, 7, 9] 判断是容器还是生成器想要判断某个值是迭代器还是容器，可以拿该值为参数，两次调用iter方法，若结果相同，则是迭代器，调用内置的next方法，即可令迭代器前进一步 123def normalize_defensive(numbers): if iter(numbers) is iter(numbers): raise TypeError('Must supply a container') 将数值或者列表转换为元组将数值转换为元组–使用(value,)即可 123&gt;&gt;&gt; a = 12&gt;&gt;&gt; (a,)(12,) 将列表转换为元组–直接强制转换即可 123&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; tuple(b)(1, 2, 3) 排序字典使用内置的方法sorted()方法进行排序sorted()语法 sorted(iterable, *, key=None, reverse=False) 对字典的key和value进行排序 1234567&gt;&gt;&gt; a = {'a':2, 'b':1, 'c':5, 'g':4, 'd':10}# 对key进行排序&gt;&gt;&gt; sorted(a)['a', 'b', 'c', 'd', 'g']# 对value进行排序&gt;&gt;&gt; sorted(a.values())[1, 2, 4, 5, 10] 根据字典的value对字典进行排序 123456# 从小到大，注意排序后的结果是列表，字典key，value被放在元组中&gt;&gt;&gt; sorted(a.items(), key=lambda x: x[1])[('b', 1), ('a', 2), ('g', 4), ('c', 5), ('d', 10)]# 从大到小&gt;&gt;&gt; sorted(a.items(), key=lambda x: x[1], reverse=True)[('d', 10), ('c', 5), ('g', 4), ('a', 2), ('b', 1)] 打乱序列语法 random.shuffle(list) Example 12345678910111213import randomdata = list(range(20))print(data)#打乱元素random.shuffle(data)&gt;&gt;&gt; data[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; random.shuffle(data)&gt;&gt;&gt; data[7, 14, 2, 11, 6, 8, 4, 15, 19, 5, 9, 0, 1, 12, 18, 13, 10, 17, 3, 16] max()方法依据自定义参数获取最大值max()语法 max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) 根据字典的value取得字典的最大键和值 12345&gt;&gt;&gt; max(a.items(), key=lambda x:x[1])('d', 10)# 如果没有指定判断的参数，则默认根据字典的key进行排序&gt;&gt;&gt; max(a.items())('g', 4) 判断是否是同一类型语法 isinstance(object, classinfo) Example 12345&gt;&gt;&gt; a = 3&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; isinstance(a, float)False 判断是否是子类语法 issubclass(class, classinfo) Example 123456789101112131415&gt;&gt;&gt; class a():... pass... &gt;&gt;&gt; class b(a):... pass... &gt;&gt;&gt; issubclass(a, b)False&gt;&gt;&gt; issubclass(b, a)True&gt;&gt;&gt; issubclass(b, b)True&gt;&gt;&gt; issubclass(b, object)True&gt;&gt;&gt; 对不确定是否存在的字典的键进行赋值语法 setdefault(key[, default]) Example 12345&gt;&gt;&gt; a = {}&gt;&gt;&gt; a.setdefault('b', 1)1&gt;&gt;&gt; a{'b': 1} 本来是这样写的代码 1234567891011&gt;&gt;&gt; def count(datas):... result = {}... for data in datas:... if data in result:... result[data] += 1... else:... result[data] = 1... return result... &gt;&gt;&gt; count(data){'a': 2, 'b': 2, 'c': 3, 'd': 1} 现在只要这样写就行了 123456789&gt;&gt;&gt; def count(datas):... result = {}... for data in datas:... result.setdefault(data, 0)... result[data] += 1... return result... &gt;&gt;&gt; count(data){'a': 2, 'b': 2, 'c': 3, 'd': 1} Decorators装饰器（Decorators）是应用包装函数的快捷方式。这有助于将功能与一些代码一遍又一遍地”包装“。举个例子，我为自己创建了一个retry装饰器，这样我可以将其运用到任何函数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数5次，并且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分有用： 1234567891011121314151617181920212223242526272829303132333435from time import sleepfrom functools import wrapsimport logginglogging.basicConfig()log = logging.getLogger('retry')def retry(f): @wraps(f) def wrapped_f(*args, **kwargs): MAX_ATTEMPTS = 5 for attempt in range(1, MAX_ATTEMPTS + 1): try: return f(*args, **kwargs) except: log.exception('Attempt %s/%s failed : %s', attempt, MAX_ATTEMPTS, (args, kwargs)) sleep(10 * attempt) log.critical('All %s attempts failed : %s', MAX_ATTEMPTS, (args, kwargs)) return wrapped_fcounter = 0@retrydef save_to_database(arg): print('Write to a database or make a network call or etc.') print('This will be automatically retried if exception is thrown.') global counter counter += 1 # 这将在第一次调用时抛出异常 # 在第二次运行时将正常工作(也就是重试) if counter &lt; 2: raise ValueError(arg)if __name__ == '__main__': save_to_database('Some bad value') 字符串补足位数通常使用的字符串格式化符号{}里面是可以带参数的 {:5} 代表此格式化的字符串至少有5位，不足的在字符串前面补充空格 {:a&gt;5} 代表此格式化的字符串至少有5位，不足的在字符串前面补充字符a（使用=效果一样） {:a&lt;5} 代表此格式化的字符串至少有5位，不足的在字符串后面补充字符a Example: 123456789&gt;&gt;&gt; a = 6&gt;&gt;&gt; '{:5}'.format(a)' 6'&gt;&gt;&gt; '{:a&gt;5}'.format(a)'aaaa6'&gt;&gt;&gt; '{:a=5}'.format(a)'aaaa6'&gt;&gt;&gt; '{:a&lt;5}'.format(a)'6aaaa' 还可以使用zfill方法进行补足，zfill可以对字符串的左边进行补足，补足元素为0，且在有+、-符号时补足元素会在符号之后 123456&gt;&gt;&gt; a = '43'&gt;&gt;&gt; a.zfill(5)'00043'&gt;&gt;&gt; b = '-43'&gt;&gt;&gt; b.zfill(5)'-0043' 获取字符的ASCII码使用python内置的ord()方法 1234&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('A')65","link":"/python/less-common-python-knowledge/"},{"title":"Virtualenv","text":"Something of a tool, the tool can easy to create isolated Python environments–Virtualenv. 本文为学习Virtualenv官方文档的笔记 英文好的出门左拐官方文档美滋滋 Why use Virtualenv?我们一般在本地会有很多项目，每个项目所依赖的包一般都是不同的，如果在整个系统的Python环境下安装各种项目需要的第三方模块会导致整个系统的Python环境十分臃肿，也很容易搞乱整个环境，造成不好修复的后果。如果我们能为每个项目都提供独立的Python运行环境与系统隔离不是美滋滋，Virtualenv就是这样美滋滋的工具Virtualenv能创建理论上无数的不同的Python运行环境，在每个环境里面我们可以做着和在系统环境下一模一样的事情，且不论你怎么弄都不会影响到全局的Python环境 InstallationTo install globally with pip(if you have pip 1.3 or greater installed globally) 1[sudo] pip install virtualenv ExampleThe following procedure indicates that the installation is successful，the installation version is 16.0.0 123456789smileorigins-MacBook-Pro:~ smileorigin$ pip3 install virtualenvCollecting virtualenv Downloading https://files.pythonhosted.org/packages/b6/30/96a02b2287098b23b875bc8c2f58071c35d2efe84f747b64d523721dc2b5/virtualenv-16.0.0-py2.py3-none-any.whl (1.9MB) 100% |████████████████████████████████| 1.9MB 88kB/s Installing collected packages: virtualenvSuccessfully installed virtualenv-16.0.0smileorigins-MacBook-Pro:~ smileorigin$ virtualenv --version16.0.0smileorigins-MacBook-Pro:~ smileorigin$ UsageVirtualenv has one basic command 1virtualenv ENV ENV is a directory to place the new virtual environment ENV/lib/ and ENV/include/ Containing supporting library files for a new virtualenv python Packages installed in this environment will live under ENV/lib/pythonX.X/site-packages/ ENV/bin/ Containing the executables – noticeably a new python Thus running a script with #! /path/to/ENV/bin/python would run that script under this virtualenv’s python pip and setuptools are installed This associated pip can be run from ENV/bin/pip Example 123456smileorigins-MacBook-Pro:~ smileorigin$ mkdir test_envsmileorigins-MacBook-Pro:~ smileorigin$ virtualenv test_envUsing base prefix '/Library/Frameworks/Python.framework/Versions/3.7'New python executable in /Users/smileorigin/test_env/bin/python3.7Also creating executable in /Users/smileorigin/test_env/bin/pythonInstalling setuptools, pip, wheel...done. Activate scriptIn a newly created virtualenv there will also be a activate shell scriptOn Posix systems, this resides in ENV , so you can run : 1source bin/activate To undo these changes to your path (and prompt), just run: 1deactivate Example 1234567smileorigins-MacBook-Pro:test_env smileorigin$ source bin/activate(test_env) smileorigins-MacBook-Pro:test_env smileorigin$ python3Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 26 2018, 23:26:24) [Clang 6.0 (clang-600.0.57)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; exit()(test_env) smileorigins-MacBook-Pro:test_env smileorigin$ deactivate Inherit global site-packagesIf you want to inherit packages from /usr/lib/python2.7/site-packages (or whatever your global site-packages directory is), you can run: 1virtualenv --system-site-packages ENV This can be used if you have control over the global site-packages directory, and you want to depend on the packages there. If you want isloation from the global system, do not use this flag.ExampleMy global python environment is 3.7.0, so we can see the result is inherit 3.7.0 1234567891011121314smileorigins-MacBook-Pro:~ smileorigin$ mkdir test_inheritsmileorigins-MacBook-Pro:~ smileorigin$ virtualenv --system-site-packages test_inheritUsing base prefix '/Library/Frameworks/Python.framework/Versions/3.7'New python executable in /Users/smileorigin/test_inherit/bin/python3.7Also creating executable in /Users/smileorigin/test_inherit/bin/pythonInstalling setuptools, pip, wheel...done.smileorigins-MacBook-Pro:~ smileorigin$ cd test_inheritsmileorigins-MacBook-Pro:test_inherit smileorigin$ source bin/activate(test_inherit) smileorigins-MacBook-Pro:test_inherit smileorigin$ python --versionPython 3.7.0(test_inherit) smileorigins-MacBook-Pro:test_inherit smileorigin$ pythonPython 3.7.0 (v3.7.0:1bf9cc5093, Jun 26 2018, 23:26:24) [Clang 6.0 (clang-600.0.57)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.","link":"/python/virtualenv/"},{"title":"Kodi","text":"Kodi媒体中心是一个屡获殊荣的自由和开源的跨平台媒体播放器和用于HTPC（Home theater PC，家庭影院PC）的数字媒体娱乐中心软件，可以运行在Linux、OSX、Windows、Android系统。它是一个优秀的自由和开源的（GPL）媒体中心软件 Installationhttp://www.kodiplayer.cn/course/2902.htmlhttps://beekc.top/2019/09/09/install-kodi-in-raspberry-pi/ 1sudo apt-get install kodi kodi-pvr-iptvsimple iptvsimple 插件可以使 kodi 收看网络电视。在网络山可以下载到扒好的IPTV直播源，在插件设置中打开直播源，就可以在 kodi 的主界面的电视中观看网络电视了 12# 后台运行kodi &amp; 开启 web 控制界面在 web 界面下，可以使用上下左右和backspace键来控制kodi界面（即树莓派连接hdmi显示出来的界面，在没有鼠标键盘连接树莓派时很有用！！！）vim .kodi/userdata/advancedsettings.xml 添加下述内容，重启树莓派后在电脑浏览器登录树莓派ip地址加2233端口网址（例如：192.168.0.109:2233）就可以看到 kodi 的 web 控制界面了 12345678&lt;advancedsettings&gt; &lt;services&gt; &lt;webserver&gt;true&lt;/webserver&gt; &lt;webserverpassword default=\"true\"&gt;&lt;/webserverpassword&gt; &lt;webserverport default=\"true\"&gt;2233&lt;/webserverport&gt; &lt;webserverusername default=\"true\"&gt;kodiPI&lt;/webserverusername&gt; &lt;/services&gt;&lt;/advancedsettings&gt; 蓝牙音箱1234567sudo apt-get updatesudo apt-get upgrade -ysudo apt-get dist-upgrade -ysudo apt-get install pi-bluetooth bluez bluez-firmware bluemansudo usermod -G bluetooth -a pisudo reboot# https://blog.csdn.net/xundh/article/details/90774157","link":"/raspberry/kodi/"},{"title":"SSD1306连接Raspberry和驱动安装","text":"树莓派安装配置 SSD1306 OLED 显示屏 连线 开启I2C功能 命令行开启I2C功能 在命令行下使用sudo raspi-config进入树莓派设置界面 UI界面开启I2C功能 在UI界面直接找到下图的红框项即可 检验是否成功开启I2C 命令行输入sudo i2cdetect -y 1 如果又看到如下类似界面，即I2C开启成功，显示屏成功连接， 3c就是oled屏幕地址 安装驱动程序 这里使用Adafruit_Python_SSD1306库,在命令行依次输入以下命令 12345678sudo apt-get updatesudo apt-get install build-essential python-dev python-pipsudo pip install RPi.GPIOsudo apt-get install python-imaging python-smbussudo apt-get install gitgit clone https://github.com/adafruit/Adafruit_Python_SSD1306.gitcd Adafruit_Python_SSD1306sudo python setup.py install 安装好库后进入Adafruit_Python_SSD1306目录下即可发现有一个example目录，里面就是程序的实例，该库使用的是Python2.x","link":"/raspberry/oled/"},{"title":"Raspbian配置","text":"记录树莓派的一些配置设置 ssh开启方式在刷完系统后，进入刷系统的内存卡的boot分区，新建一个ssh的文件（无后缀）开机后树莓派即会自动开启ssh功能，用户名为：pi，密码为：raspberry 连接Wifi修改 /boot 分区文件读卡器读取内存卡后，在 /boot分区下新建一个wpa_supplicant.conf文件，增加以下内容 1234567country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ ssid=\"bilibili\" psk=\"smileorigin\"} 命令行直接修改配置文件方式 查看能搜索到的wifi iwlist scan 编辑wifi文件达到实现wifi 123456sudo nano /etc/wpa_supplicant/wpa_supplicant.conf# add in the endnetwork={ ssid = \"wifi name\" psk = \"wifi password\"} 修改/etc/network/interface 文件 12345678910auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0allow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid 接入AP的名字wpa－psk 接入AP的密码 # using this command to restart wifisudo /etc/init.d/networking restart 设置中文 安装中文字体sudo apt-get install ttf-wqy-zenhei 安装中文输入法sudo apt-get install scim-pinyin 软件源 中国科学技术大学Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/清华大学Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/华中科技大学Raspbian http://mirrors.hustunique.com/raspbian/raspbian/Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/大连东软信息学院源（北方用户）Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/重庆大学源（中西部用户）Raspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/新加坡国立大学Raspbian http://mirror.nus.edu.sg/raspbian/raspbian牛津大学Raspbian http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/韩国KAIST大学Raspbian http://ftp.kaist.ac.kr/raspbian/raspbian/ 更换软件源操作sudo nano /etc/apt/sources.list打开文件后清空文件内容，粘贴以下镜像路径:deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contribdeb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contrib 更新软件索引清单sudo apt-get update 比较索引清单更新依赖关系sudo apt-get upgrade -y 配置VNV Viewer由于最新版的Raspbian已经内置了VNC了所以只要进入设置将VNC打开然后重启Raspberry即可 打开设置界面sudo raspi-config 选择Interfacing Options,进入菜单后选择VNC，然后按提示开启VNC即可 重启，在ssh下输入sudo reboot重新启动即完成了开启VNC开启后就默认是开机自启了，所以不用设置开机自启 超频修改配置文件 拔下内存卡，用读卡器连接至电脑 打开根目录下的config.txt文件 在里面添加以下内容123456#CPU超频至1.4GHz arm_freq=1400#内核电压提高至1.3V；范围：0~6；初始电压1.2V，每增加1提高0.025Vover_voltage=4#GPU超频至450MHzgpu_freq=450 保存后将内存卡插回Raspberry pi 3b+，启动系统 测试是否成功 安装sysbeach，开源多核性能测试软件sudo apt-get install sysbench 运行程序进行满负载性能测试,开启另一个命令行程序输入以下命令sysbench --num-threads=4 --test=cpu --cpu-max-prime=20000 run 查看满负载下CPU频率sudo cat /sys/devices/system/cpu/cpu2/cpufreq/cpuinfo_cur_freq 如果返回1400000，则超频成功","link":"/raspberry/respberry-config/"},{"title":"资源（你懂的）","text":"记录收集的一些不错的网站，包含工具型网站、设计网站、资讯网站。。。长期更新。。。未完待续 工具型网站 在线工具 点我包含各种各样的在线工具，很方便 在线MD5加密解密 点我可以在线进行数据的MD5加密和解密，免费，十分良心! 正则表达式测试网站 点我测试正则表达式的书写是否有错 MSDN 点我各种微软的系统镜像，软件，大神维护的很良心 笔记本屏幕在线检测 点我检测屏幕：纯色、漏光测试、干扰测试、对焦、呼吸效应、对比度、色阶、饱和度 蓝点网 点我各种Windows相关的软件和技术 脚本之家 点我有很多的技术书籍可以在脚本之家找到PDF电子版，虽然不是正版，但还是很够用的 SM.MS 点我公共图床，百度下你就知道图床是干啥的了，哈哈(现在访问图床生成的外链需要穿墙) keybr 点我在线练习打字，高逼格 工具 MarkdownPad2 Pro注册码 点我福利，Windows平台上最优秀的Markdown编辑器之一的MarkdownPad的pro版注册码 Lepton 点我代码片段收集工具利用了Github实现的小工具免费，很不错 MarkEditor 点我最好用的Markdown编辑器没有之一，不过要收费，终身pro版128毛爷爷，但是很不错值得（PS：网上有破解版，但是建议购买正版，本人购买正版使用，支持这类高逼格的作品） 设计相关 Materia Design Palette 点我Materia Design风格Android界面预览调色 Color Hunt 点我各种颜色，需要颜色可以到上面找找 iconmonstr 点我图标网站很全，纯色黑白图标为主 Iconfont 点我阿里巴巴图标库，非常全，各种样式都有，彩色的也有，可以自己搭配颜色和选择大小，非常赞 PS家园网 点我各种字体的PS字体可直接下载使用 逼格PPT 点我很不错的PPT模板网站 学习网站 PS教程自学网 点我自学PS网站 W3 school 点我自学HTML相关知识的网站 未完待续，最后更新2018-11-10 10:28:55","link":"/tools/share/"},{"title":"温控散热","text":"记录树莓派配置温控散热风扇 接线风扇红线 接 树莓派5V，比如4号引脚风扇黑线 接 三极管C三极管E极 接 树莓派0V，比如6号引脚三极管B极 接 GPIO， 我用的8号引脚GPIO14 Raspberry Pi3 Model B GPIO针脚定义三极管顾名思义，它有3个极。分别是E发射机、B基极、C集极。可以理解为E极是正极、C极是负极、B极是信号极控制是否通电。和二极管一样，正极接电源正极，负极接电源的负极。S8050的引脚示意图如下： 网上的温控代码地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# encoding: utf-8import RPi.GPIOimport timeimport sysimport mathRPi.GPIO.setwarnings(False)RPi.GPIO.setmode(RPi.GPIO.BCM)gpio=14RPi.GPIO.setup(gpio, RPi.GPIO.OUT)pwm = RPi.GPIO.PWM(gpio, 440)RPi.GPIO.setwarnings(False)#风扇能保持旋转的最低速度，需要自己尝试min_speed=20.0#希望cpu温度稳定在多少temperature=39400prv_speed = 0.0speed_fin=50.0max_step=3.0def sigmoid(x): x=x/4000.0 result= 2.0*max_step/(1+math.exp(-x))-max_step return result try: pwm.start(0) while True: tmpFile = open( '/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/temp1_input' ) cpu_temp = int(tmpFile.read()) tmpFile.close() speed_fin=speed_fin+sigmoid(cpu_temp-temperature) speed_fin = min( speed_fin, 100.0 ) speed_fin = max( speed_fin, min_speed-0.5 ) if speed_fin &lt; min_speed: speed=0 else: speed=speed_fin if prv_speed == 0.0 : if speed!=0.0 : pwm.ChangeDutyCycle(100) time.sleep(0.3) print \"start\" prv_speed = speed pwm.ChangeDutyCycle(speed) time.sleep(2)except KeyboardInterrupt: passpwm.stop() 我自己修改后的温控代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python3# encoding: utf-8import RPi.GPIOimport timeimport sysimport mathRPi.GPIO.setwarnings(False)RPi.GPIO.setmode(RPi.GPIO.BCM)#这里根据自己接法修改gpio=14RPi.GPIO.setup(gpio, RPi.GPIO.OUT)pwm = RPi.GPIO.PWM(gpio, 100)speed = 100#风扇最小能保持旋转的速度，低于这个速度可能停转，需要拿自己的风扇测试然后修改speed_min=20.0#启动风扇的温度35000~60000temperature_start=35000max_speed_temperature = 46000temperature_cpu_last = 0def getSpeed(temperature): speed = min((temperature/max_speed_temperature) * (100 - speed_min) + speed_min,100) return speedtry: pwm.start(0) while True: temperatureFile = open('/sys/class/thermal/thermal_zone0/temp') temperature_cpu = int(temperatureFile.read()) temperatureFile.close() print('now cpu temperature is: {}'.format(temperature_cpu)) if temperature_cpu &gt;= temperature_start: if temperature_cpu_last &lt; temperature_start: # print('---------------first start fan--------------') pwm.ChangeDutyCycle(100) time.sleep(.1) speed = getSpeed(temperature_cpu) print('fan speed is: {}'.format(speed)) pwm.ChangeDutyCycle(speed) else: pwm.stop() temperature_cpu_last = temperature_cpu time.sleep(3) except KeyboardInterrupt: # print('interrupt') passpwm.stop() 设置开机自启动 给Python脚本设置权限 chmod +x + python脚本位置 + 名称,example:chmod +x /home/Python/Fan.py 新建开机启动脚本在/etc/init.d目录下新建一个文件，如sudo nano /etc/init.d/fan，然后粘贴下列内容,并将对应的自己的路径替换： 12345678910111213141516171819202122232425262728#!/bin/sh#/etc/init.d/fan### BEGIN INIT INFO# Provides: fan# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: fan# Description: This service is used to start fan control### END INIT INFOcase \"$1\" in start) echo \"Starting app\" python /home/pi/Python/fan.py ;; stop) echo \"Stop\" #kill $( ps aux | grep -m 1 'python /home/pi/Python/fan.py' | awk '{ print $2 }') ;; *) echo \"Usage: service fan start|stop\" exit 1 ;;esacexit 0 设置启动脚本权限 sudo chmod +777 /etc/init.d/fan 设置开机自启 sudo update-rc.d fan defaults 启动脚本以后可以使用service命令 sudo service fan start 关闭脚本service命令 sudo service fan stop","link":"/raspberry/temperature-controlled-cooling/"},{"title":"数据库三范式（笔记）","text":"以下内容摘自百度百科用作个人笔记，便于查看，并非原创 概念设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小 第一范式（1NF） 所谓的第一范式指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合、数组、记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式表中的每个域只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域 在任何一个关系型数据库中，第一范式是对关系模式设计基本要求，一般设计中都必须满足第一范式。不过有些关系模型中突破了第一范式的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型 第二范式（2NF） 在第一范式的基础上，非码属性必须完全依赖于候选码（在第一范式基础上消除非主属性对主码的部分函数依赖） 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如：在员工表中的身份证号码可以实现每个员工的区分，该身份证即为候选键，任何一个候选键都可以被选做主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计譬如ID等不重复的编号以实现区分，被添加的编号或ID选做主键 第二范式要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键 第三范式（3NF） 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入到员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足第二范式的基础上，任何非主属性不得传递依赖于主属性 实例学生系统为例分析三范式的应用 第一范式（1NF）数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的第一列再分为二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的首先我们确定要设计的内容包括哪些：学号、学生姓名、年龄、性别、课程名称、课程学分、系别、学科成绩、系办地址、系办电话等信息。为了简单我们暂时只考虑这些字段信息。我们对于这些信息，所关心的问题有如下几个方面 学生有哪些基本信息？ 学生选了哪些课，成绩是什么？ 每个课的学分是多少？ 学生属于哪个系，系的基本信息是什么？ 第二范式（2NF）第二范式（2NF）首先，我们考虑把所有这些信息放到一个表中（学号、学生姓名、年龄、性别、课程、课程学分、系别、学科成绩、系办地址、系办电话）下面存在如下的依赖关系（学号， 课程名称） –&gt; （姓名， 年龄， 成绩， 学分） 问题分析 不满足第二范式的要求，会产生如下问题： 数据冗余 同一门课程由n个学生选修，“学分”就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次 更新异常 若调整了某门课程的学分，数据表中所有行的“学分”值都要更新，否则会出现同一门课程学分不同的情况 假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有“学号”关键字，课程名称和学分也无法记录入数据库 删除异常 假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常 解决方案 把选课关系表SelectCourse改为如下三个表： 学生：Student（学号、 姓名、 年龄、 性别、 系办地址、 系办电话） 课程：Course（课程名称、 学分） 选课关系：SelectCourse（学号、 课程名称、 成绩） 第三范式（3NF）接着看上面的学生表Student（学号、 姓名、 年龄、 性别、 系别、 系办地址、 系办电话），关键字为单一关键字“学号”，因为存在如下决定关系：（学号） –&gt; （姓名、 年龄、 性别、 系别、 系办地址、 系办电话）但是还存在下面的决定关系：（学号） –&gt; （系别） –&gt; （系办地点、 系办电话）即存在非关键字段“系办电话”、 “系办电话”对关键字段“学号”的传递函数依赖它也会存在数据冗余、更新异常、插入异常和删除异常的情况根据第三范式把学生关系表分为如下两个表就可以满足第三范式： 学生：（学号、 姓名、 年龄、 性别、 系别） 系别：（系别、 系办地址、 系办电话）上面的数据库表就是符合I、II、III范式的，消除了数据冗余、更新异常、插入异常和删除异常","link":"/database/paradigm/"},{"title":"Vibrate(手机振动器的使用)","text":"在此用来记录使用手机震动器的代码 12345678910111213141516171819202122232425262728293031323334/** * 项目名称：DynamicTranslate * 类描述： * 创建人：smileorigin * 创建时间：2017/4/3 16:44 * 修改人：smileorigin * 修改时间：2017/4/3 16:44 * 修改备注： */public class VibrateUtils { private VibrateUtils(){} /** * 开始震动 * * @param context 上下文对象 * @param time 震动时长 */ public static void startVibrate(Context context, long time){ Vibrator vibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE); vibrator.vibrate(time); } /** * 设置icon的点击震动效果 * * @param context 上下文对象 */ public static void startVibrateIcon(Context context) { Vibrator vibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE); vibrator.vibrate(50); }}","link":"/android/utils/vibrate/"},{"title":"Android Preference","text":"应用通常包括允许用户修改应用特性和行为的设置例如，有些应用允许用户指定是否启用通知，或指定应用与云端同步数据的频率若要为应用提供设置，您应该使用 Android 的 Preference API 构建一个与其他 Android 应用中的用户体验一致的界面（包括系统设置）。本文旨在介绍如何使用 Preference API 构建应用设置 首先要在res文件夹下新建一个xml文件夹，然后新建一个xml文件，一般为preference 每个xml文件的根节点必须为一个PreferenceScreen，在PreferenceScreen里面添加的每个Preference将视为一个单独的项，可使用PreferenceCategory进行分组 android:key对于要保留数据值的首选项，必须拥有此属性。它指定系统在将此设置的值保存在 SharedPreferences 中时所用的唯一键（字符串）。不需要此属性的唯一情形是：首选项是 PreferenceCategory 或PreferenceScreen，或者首选项指定要调用的 Intent（使用 元素）或要显示的 Fragment（使用 android:fragment 属性）。android:title此属性为设置提供用户可见的名称。android:defaultValue此属性指定系统应该在 SharedPreferences 文件中设置的初始值。您应该为所有设置提供默认值。 将Preference放进Preference中后，每两个Preference之间将会由横线隔开 每个设置界面要依托在一个Activity或者Fragment上，使用Activity的话要继承PreferenceActivity，使用Fragment的话要继承PreferenceFragment，两种情况下都不需要在加载视图，直接使用设置列表，在onCreate（）中添加需要的设置列表1addPreferencesFromResource(R.xml.preferences); 设置默认值您创建的首选项可能会为应用定义一些重要行为，因此在用户首次打开应用时，您有必要使用每个 Preference 的默认值初始化相关的 SharedPreferences 文件。首先，您必须使用 android:defaultValue 属性为 XML 文件中的每个 Preference 对象指定默认值。该值可以是适合相应 Preference 对象的任意数据类型。例如：然后，通过应用的主 Activity（以及用户首次进入应用所藉由的任何其他 Activity）中的 onCreate() 方法调用 setDefaultValues()：PreferenceManager.setDefaultValues(this, R.xml.advanced_preferences, false);在 onCreate() 期间调用此方法可确保使用默认设置正确初始化应用，而应用可能需要读取这些设置以确定某些行为（例如，是否在蜂窝网络中下载数据）。此方法采用三个参数：应用 Context。 要为其设置默认值的首选项 XML 文件的资源 ID。 一个布尔值，用于指示是否应该多次设置默认值。如果该值为 false，则仅当过去从未调用此方法时（或者默认值共享首选项文件中的 KEY_HAS_SET_DEFAULT_VALUES为 false 时），系统才会设置默认值。只要将第三个参数设置为 false，您便可在每次启动 Activity 时安全地调用此方法，而不必通过重置为默认值来替代用户已保存的首选项。 但是，如果将它设置为 true，则需要使用默认值替代之前的所有值。 PreferenceManager.setDefaultValues(this, R.xml.advanced_preferences, false); 读取首选项默认情况下，应用的所有首选项均保存到一个可通过调用静态方法 PreferenceManager.getDefaultSharedPreferences() 从应用内的任何位置访问的文件中。 这将返回 SharedPreferences 对象，其中包含与 PreferenceActivity 中所用 Preference 对象相关的所有键值对。 例如，从应用中的任何其他 Activity 读取某个首选项值的方法如下： SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); String syncConnPref = sharedPref.getString(SettingsActivity.KEY_PREF_SYNC_CONN, \"\"); 一般在Activity的onResume()和onPause()分别注册和注销SharedPreferences.OnSharedPreferenceChangeListener 以下是详细代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package www.lollipopstudio.top.settingpreference;import android.content.SharedPreferences;import android.os.Bundle;import android.preference.EditTextPreference;import android.preference.ListPreference;import android.preference.MultiSelectListPreference;import android.preference.PreferenceActivity;import android.view.LayoutInflater;import android.view.View;import android.widget.LinearLayout;import static www.lollipopstudio.top.settingpreference.R.xml.preference;public class MainActivity extends PreferenceActivity implements SharedPreferences.OnSharedPreferenceChangeListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //加载toolbar LinearLayout root = (LinearLayout)findViewById(android.R.id.list).getParent().getParent().getParent(); View bar = LayoutInflater.from(this).inflate(R.layout.toolbar, root, false); root.addView(bar, 0); android.support.v7.widget.Toolbar toolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.toolbar); toolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } }); addPreferencesFromResource(preference); } @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) { switch (key) { case \"switch\": case \"ringtone\": case \"checkbox\": break; case \"multi\": setMultiListPreferenceSummary(key); break; case \"single\": setListPreferenceSummary(key); break; case \"editText\": setText(key); break; } } @Override protected void onResume() { super.onResume(); getPreferenceScreen().getSharedPreferences().registerOnSharedPreferenceChangeListener(this); setListPreferenceSummary(\"single\"); setMultiListPreferenceSummary(\"multi\"); setText(\"editText\"); } @Override protected void onPause() { super.onPause(); getPreferenceScreen().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this); } private void setListPreferenceSummary(String preferenceKey) { ListPreference preference = (ListPreference)findPreference(preferenceKey); preference.setSummary(preference.getEntry()); } private void setMultiListPreferenceSummary(String preferenceKey) { MultiSelectListPreference preference = (MultiSelectListPreference)findPreference(preferenceKey); preference.setSummary(preference.getValues().toString()); } private void setText(String preferenceKey) { EditTextPreference preference = (EditTextPreference)findPreference(preferenceKey); preference.setSummary(preference.getText()); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;PreferenceCategory android:title=\"Something\"&gt; &lt;CheckBoxPreference android:defaultValue=\"true\" android:key=\"checkBoxFirst\" android:icon=\"@drawable/ic_build_black_24dp\" android:title=\"CheckBox\"/&gt; &lt;SwitchPreference android:icon=\"@drawable/ic_album_black_24dp\" android:defaultValue=\"false\" android:key=\"switch\" android:title=\"Switch preference\"/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"Select\"&gt; &lt;ListPreference android:defaultValue=\"A\" android:entries=\"@array/singleSelect\" android:entryValues=\"@array/singleSelectValues\" android:key=\"single\" android:title=\"Single select\"/&gt; &lt;MultiSelectListPreference android:entries=\"@array/singleSelect\" android:entryValues=\"@array/singleSelectValues\" android:key=\"multi\" android:title=\"Multi select list preference\"/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"OpenSettingInOtherScreen\"&gt; &lt;PreferenceScreen android:title=\"OtherScreen\"&gt; &lt;Preference android:layout=\"@layout/toolbar\"/&gt; &lt;CheckBoxPreference android:defaultValue=\"true\" android:key=\"checkbox\" android:title=\"Checkbox\"&gt; &lt;/CheckBoxPreference&gt; &lt;/PreferenceScreen&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"OpenOtherActivity\"&gt; &lt;Preference android:title=\"OpenOtherActivity\"&gt; &lt;intent android:action=\"android.intent.action.otherAcyivity\"/&gt; &lt;/Preference&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"Other\"&gt; &lt;Preference android:title=\"OpenWeb\"&gt; &lt;intent android:action=\"android.intent.action.VIEW\" android:data=\"http://www.exale.com\"/&gt; &lt;/Preference&gt; &lt;RingtonePreference android:defaultValue=\"\" android:key=\"ringtone\" android:title=\"Ringtone preference\"/&gt; &lt;EditTextPreference android:defaultValue=\"describe\" android:key=\"editText\" android:title=\"EditText\"/&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"singleSelect\"&gt; &lt;item name=\"A\"&gt;A&lt;/item&gt; &lt;item name=\"B\"&gt;B&lt;/item&gt; &lt;item name=\"C\"&gt;C&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=\"singleSelectValues\"&gt; &lt;item name=\"A\"&gt;A&lt;/item&gt; &lt;item name=\"B\"&gt;B&lt;/item&gt; &lt;item name=\"C\"&gt;C&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.AppBarLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:minHeight=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:navigationIcon=\"?attr/homeAsUpIndicator\" app:title=\"setting2\"&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.AppBarLayout&gt;","link":"/android/guide/setting/"},{"title":"IO操作工具类","text":"在此用来记录一些日常开发中会用到的IO操作的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474/** * 部分来自网络 */public class IOUtil { public IOUtil() { } public static void delete(File file) { file.delete(); } public static void delete(String file) { (new File(file)).delete(); } public static void mv(String source, String target) { try { Runtime.getRuntime().exec(String.format(\"mv %s %s\", new Object[]{source, target})); } catch (IOException var3) { var3.printStackTrace(); } } public static void mv(File source, File target) { target.deleteOnExit(); source.renameTo(target); } public static String readString(String file) throws IOException { return readString(new File(file)); } public static String readString(File file) throws IOException { FileInputStream in = new FileInputStream(file); String str = readString((InputStream) in); in.close(); return str; } public static byte[] readBytes(InputStream in) throws IOException { byte[] buf = new byte[1024]; ByteArrayOutputStream out = new ByteArrayOutputStream(); boolean c = false; int c1; while ((c1 = in.read(buf)) &gt; 0) { out.write(buf, 0, c1); } byte[] bytes = out.toByteArray(); out.close(); return bytes; } public static byte[] readBytes(String path) throws IOException { FileInputStream in = new FileInputStream(path); byte[] bytes = readBytes((InputStream) in); in.close(); return bytes; } public static String readString(InputStream in) throws IOException { byte[] bytes = readBytes(in); return new String(bytes, \"UTF-8\"); } public static void writeString(OutputStream out, String str) throws IOException { out.write(str.getBytes()); } public static void appendString(OutputStream out, String str) throws IOException { out.write(str.getBytes()); } public static void appendString(File file, String str) throws IOException { FileOutputStream out = new FileOutputStream(file, true); out.write(str.getBytes()); out.close(); } public static void appendString(String file, String str) throws IOException { appendString(new File(file), str); } public static void writeString(File file, String str) throws IOException { FileOutputStream out = new FileOutputStream(file); out.write(str.getBytes()); out.close(); } public static void writeUTF8String(File file, String str) throws IOException { OutputStreamWriter outw = new OutputStreamWriter(new FileOutputStream(file), \"UTF-8\"); outw.write(str); outw.close(); } public static void writeUTF8String(String file, String str) throws IOException { writeUTF8String(new File(file), str); } public static void writeString(String file, String str) throws IOException { writeString(new File(file), str); } public static void copy(InputStream in, String target) throws IOException { FileOutputStream out = null; try { out = new FileOutputStream(new File(target)); byte[] buf = new byte[10240]; boolean c = false; int c1; while ((c1 = in.read(buf)) &gt; 0) { out.write(buf, 0, c1); } } finally { if (out != null) { try { out.flush(); out.close(); } catch (IOException var10) { var10.printStackTrace(); } } } } public static void copy(String source, String target) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(new File(source)); out = new FileOutputStream(new File(target)); byte[] e = new byte[1024]; boolean c = false; int c1; while ((c1 = in.read(e)) &gt; 0) { out.write(e, 0, c1); } } finally { if (in != null) { try { in.close(); } catch (IOException var20) { var20.printStackTrace(); } } if (out != null) { try { out.flush(); out.close(); } catch (IOException var19) { var19.printStackTrace(); } } } } public static boolean copyWithFileLock(String source, String target) { FileInputStream in = null; FileOutputStream out = null; FileChannel fileChannel = null; File targetFile = new File(target); FileLock fileLock = null; boolean hasBeenLocked = false; try { in = new FileInputStream(new File(source)); out = new FileOutputStream(targetFile, true); //用源文件做锁，不然目标文件会被置空 fileChannel = out.getChannel(); fileLock = fileChannel.tryLock(); if (fileLock == null) { hasBeenLocked = true; fileLock = fileChannel.lock(); } //由于是复制，所以复制一次就够了，等其他地方复制完毕，就返回 if (hasBeenLocked) { return true; } out = new FileOutputStream(targetFile); byte[] e = new byte[1024]; boolean c = false; int c1; while ((c1 = in.read(e)) &gt; 0) { out.write(e, 0, c1); } out.flush(); out.close(); return true; } catch (FileNotFoundException var21) { var21.printStackTrace(); return false; } catch (IOException var22) { var22.printStackTrace(); } finally { if (fileLock != null) { try { fileLock.release(); } catch (IOException e) { e.printStackTrace(); } } if (in != null) { try { in.close(); } catch (IOException var20) { var20.printStackTrace(); } } if (out != null) { try { out.close(); } catch (IOException var19) { var19.printStackTrace(); } } } return false; } public static void serialize(Serializable obj, String file) throws FileNotFoundException, IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); try { oos.writeObject(obj); } catch (IOException var11) { var11.printStackTrace(); throw var11; } finally { try { oos.close(); } catch (IOException var10) { var10.printStackTrace(); } } } public static Object unserialize(String file) throws Exception { ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(file)); Object var4 = ois.readObject(); return var4; } catch (Exception var12) { ; } finally { try { if (ois != null) { ois.close(); } } catch (IOException var11) { var11.printStackTrace(); } } return null; } public static Object cloneObject(Object obj) { ByteArrayOutputStream out = new ByteArrayOutputStream(); ByteArrayInputStream in = null; ObjectInputStream ois = null; ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(out); oos.writeObject(obj); in = new ByteArrayInputStream(out.toByteArray()); ois = new ObjectInputStream(in); return ois.readObject(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if (oos != null) oos.close(); if (ois != null) ois.close(); if (in != null) in.close(); out.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } return null; } public static void saveToFile(InputStream in, String file) throws IOException { File outputFile = new File(file); outputFile.deleteOnExit(); outputFile.getParentFile().mkdirs(); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile)); byte[] buffer = new byte[2048]; int length = in.read(buffer); while (length != -1) { outputStream.write(buffer, 0, length); length = in.read(buffer); } outputStream.flush(); outputStream.close(); } public static void saveToFile(InputStream in, File file) throws IOException { File outputFile = file; outputFile.deleteOnExit(); outputFile.getParentFile().mkdirs(); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile)); byte[] buffer = new byte[2048]; int length = in.read(buffer); while (length != -1) { outputStream.write(buffer, 0, length); length = in.read(buffer); } outputStream.flush(); outputStream.close(); } /** * 获得指定文件的byte数组 */ public static byte[] getBytes(String filePath) { byte[] buffer = null; try { File file = new File(filePath); FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length()); byte[] b = new byte[(int) file.length()]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); bos.close(); buffer = bos.toByteArray(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return buffer; } public static boolean deleteDirs(String themePath) { LinkedList&lt;File&gt; themeLinkedList = new LinkedList&lt;File&gt;(); File themeDir = new File(themePath); if (!themeDir.exists()) { return true; } else if (themeDir.isDirectory()) { themeLinkedList.addAll(Arrays.asList(themeDir.listFiles())); while (!themeLinkedList.isEmpty()) deleteContent(themeLinkedList.pollLast()); } else { return themeDir.delete(); } return true; } private static void deleteContent(File file) { LinkedList&lt;File&gt; themeLinkedList = new LinkedList&lt;File&gt;(); if (file.isDirectory()) { themeLinkedList.addAll(Arrays.asList(file.listFiles())); while (!themeLinkedList.isEmpty()) { File subFile = themeLinkedList.pollLast(); deleteContent(subFile); } } file.delete(); } public static void copyFile(String srcPath, String desPath) throws IOException { File srcDir = new File(srcPath); File desDir = new File(desPath); if (!srcDir.exists()) { return; } if (srcDir.isDirectory()) { desDir.mkdirs(); File[] files = srcDir.listFiles(); for (int i = 0; i &lt; files.length; i++) { File file = files[i]; File des = new File(desDir, file.getName()); copyFile(file.getAbsolutePath(), des.getAbsolutePath()); } } else { desDir.getParentFile().mkdirs(); IOUtil.copy(srcPath, desPath); } } /** * 获取SDCARD的绝对路径 * * @return Environment.getExternalStorageDirectory().getAbsolutePath() */ public static String getSdcardPath() { return Environment.getExternalStorageDirectory().getAbsolutePath(); } /** * 获取文件夹大小 * @param file File实例 * @return long */ public static long getFolderSize(File file) { long size = 0; try { java.io.File[] fileList = file.listFiles(); if (fileList != null) { for (int i = 0; i &lt; fileList.length; i++) { if (fileList[i].isDirectory()) { size = size + getFolderSize(fileList[i]); } else { size = size + fileList[i].length(); } } } } catch (Exception e) { e.printStackTrace(); } return size; } /** * 获取缓存路径 * * @param context * @return */ public static String getCachePath(Context context) { String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment .getExternalStorageState()) || !Environment.isExternalStorageRemovable()) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return cachePath; }}","link":"/android/utils/io/"},{"title":"MySQL 多表操作","text":"There is recorded some MySQL multilist operation. 多表查询 使用别名进行多表查询 123456789mysql&gt; select t1.* from t_user t1, t_deptment t2 where t1.id = t2.id;+----+------+------+| id | name | sex |+----+------+------+| 1 | u1 | a || 2 | u2 | b || 3 | u3 | c |+----+------+------+3 rows in set (0.00 sec) 12345678910mysql&gt; select t1.id,t1.name, t2.id,t2.name from -&gt; t_user t1, t_deptment t2 -&gt; where t1.id = t2.id -&gt; and t2.id = 2;+----+------+----+------+| id | name | id | name |+----+------+----+------+| 2 | u2 | 2 | bb |+----+------+----+------+1 row in set (0.00 sec) 如果在GROUP BY后接WHERE的话会报错，GROUP BY后不能接WHERE子句，但是可以接HAVING子句 12mysql&gt; select id from t_user group by id where id &gt; 2;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'where id &gt; 2' at line 1 12345678mysql&gt; select id from t_user group by id having id &gt; 2;+----+| id |+----+| 3 || 4 |+----+2 rows in set (0.00 sec) 多表连接多表连接记得使用条件判断取出拥有相同条件的多表的数据，否则会出现重复的数据多个表使用多个inner join连接要查询的表 12345678910111213141516171819mysql&gt; select * from t1;+----+------+| c1 | c2 |+----+------+| a | b || b | c || c | d |+----+------+3 rows in set (0.00 sec)mysql&gt; select * from t2;+----+------+| c3 | c4 |+----+------+| b | d || c | f || h | j |+----+------+3 rows in set (0.00 sec) 内连接将两个表符合条件的数据查询出来并列在一起 12345678mysql&gt; select * from t1 inner join t2 on c1 = c3;+----+------+----+------+| c1 | c2 | c3 | c4 |+----+------+----+------+| b | c | b | d || c | d | c | f |+----+------+----+------+2 rows in set (0.00 sec) 左连接将两个表符合条件的数据查询出来并列在一起，不符合的数据只放置第一个表的数据，另一个表的数据置空 123456789mysql&gt; select * from t1 left join t2 on c1 = c3;+----+------+------+------+| c1 | c2 | c3 | c4 |+----+------+------+------+| b | c | b | d || c | d | c | f || a | b | NULL | NULL |+----+------+------+------+3 rows in set (0.00 sec) 右连接将两个表符合条件的数据查询出来并列在一起，不符合的数据只放置第二个表的数据，另一个表的数据置空 123456789mysql&gt; select * from t1 right join t2 on c1 = c3;+------+------+----+------+| c1 | c2 | c3 | c4 |+------+------+----+------+| b | c | b | d || c | d | c | f || NULL | NULL | h | j |+------+------+----+------+3 rows in set (0.00 sec)","link":"/database/mysql/multi-table-operation/"},{"title":"MD5","text":"在此用来记录使用MD5进行操作的代码 123456789101112131415161718192021222324252627282930public class MD5Utils { public static String getMd5(String content){ MessageDigest digest = null; try { digest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e1) { e1.printStackTrace(); } byte[] result = digest.digest(content.getBytes()); StringBuffer sb = new StringBuffer(); for (byte b : result) { int i = b &amp; 0xff;// 将字节转为整数 String hexString = Integer.toHexString(i);// 将整数转为16进制 if (hexString.length() == 1) { hexString = \"0\" + hexString;// 如果长度等于1, 加0补位 } sb.append(hexString); } return sb.toString(); }}","link":"/android/utils/md5/"},{"title":"PAT解题记录","text":"题目来自PAT网站的 BasicLevel 题目本文用来记录个人解答的PAT题目，仅供个人学习使用，未经允许不得转载，以下均为Python3解法 1001 害死人不偿命的(3n+1)猜想 (15)卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。输出格式：输出从n计算到1需要的步数。输入样例： 13 输出样例： 15 Solution 123456789101112def solution(n): step = 0 while n &gt; 1: step += 1 if n % 2 == 0: n /= 2 else: n = (3 * n + 1) / 2 return steptest = int(input())print(solution(test)) 1002 写出这个数 (20)读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100^。输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。输入样例： 11234567890987654321123456789 输出样例： 1yi san wu Solution 1234567def solution(n): sum_str = str(sum(map(int, n))) table = {'0':'ling', '1':'yi', '2':'er', '3':'san', '4':'si', '5':'wu', '6':'liu', '7':'qi', '8':'ba', '9':'jiu'} return ' '.join([table[key] for key in sum_str])test = input()print(solution(test)) 1004 成绩排名 (20)读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。输入格式：每个测试输入包含1个测试用例，格式为: 12345第1行：正整数n第2行：第1个学生的姓名 学号 成绩第3行：第2个学生的姓名 学号 成绩... ... ...第n+1行：第n个学生的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。输入样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 Solution 12345678910def solution(count, grades): grades = sorted(grades, key=lambda grade: int(grade[2]), reverse=True) print('{} {}'.format(grades[0][0], grades[0][1])) print('{} {}'.format(grades[count-1][0], grades[count-1][1]))count = int(input())data = []for i in range(count): data.append(input().split(' '))solution(count, data) 1006 换个格式输出整数 (15)让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&amp;lt10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。输入格式：每个测试输入包含1个测试用例，给出正整数n（&amp;lt1000）。输出格式：每个测试用例的输出占一行，用规定的格式输出n。输入样例1： 1234 输出样例1： 1BBSSS1234 输入样例2： 123 输出样例2： 1SS123 Solution 1234567def solution(n): nums = list(map(int, n)) nums = [0] * (3 - len(nums)) + nums print('B' * nums[0] + 'S' * nums[1] + ''.join([str(num) for num in range(1, nums[2]+1)]))test = input()solution(test) 1009 说反话 (20)给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。输出格式：每个测试用例的输出占一行，输出倒序后的句子。输入样例： 1Hello World Here I Come 输出样例： 1Come I Here World Hello Solution 12345def solution(english): return ' '.join(english[::-1])english = input().split()print(solution(english)) 1010 一元多项式求导（25）设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nxn−1。）输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。输入样例: 13 4 -5 2 6 1 -2 0 输出样例: 112 3 -10 1 6 0 Solution: 12345678910111213def solution(nums): result = [] for i in range(0, len(nums), 2): coe, index = nums[i], nums[i+1] if index == 0: continue result.append('{} {}'.format(coe*index, index-1)) if not result: result.append('0 0') return resultnums = list(map(int, input().split()))print(' '.join(solution(nums))) 1011 A+B和C (15)给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。输入格式：输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。输出格式：对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。输入样例： 1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例： 1234Case #1: falseCase #2: trueCase #3: trueCase #4: false Solution 123456789def solution(abcs): for i in range(len(abcs)): print('Case #{}: {}'.format(i + 1, str(abcs[i][0] + abcs[i][1] &gt; abcs[i][2]).lower()))count = int(input())abcs = []for i in range(count): abcs.append(list(map(int, input().split())))solution(abcs) 1012 数字分类 (20)给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：A1 = 能被5整除的数字中所有偶数的和；A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；A3 = 被5除后余2的数字的个数；A4 = 被5除后余3的数字的平均数，精确到小数点后1位；A5 = 被5除后余4的数字中最大数字。输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。输出格式：对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出“N”。输入样例1： 113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 130 11 2 9.7 9 输入样例2： 18 1 2 4 5 6 7 9 16 输出样例2： 1N 11 2 N 9 Solution 123456789101112131415161718192021222324252627def solution(nums): a1, a2, a3, a4, a5 = 0, 0, 0, [], [] symbol, flag = 1, False for num in nums: remainder = num % 5 if remainder == 0 and num % 2 == 0: a1 += num elif remainder == 1: a2 = a2 + symbol * num symbol *= -1 flag = True elif remainder == 2: a3 += 1 elif remainder == 3: a4.append(num) elif remainder == 4: a5.append(num) a1 = a1 if a1 &gt; 0 else 'N' a2 = a2 if flag &gt; 0 else 'N' a3 = a3 if a3 &gt; 0 else 'N' a4 = round(sum(a4) / len(a4), 1) if len(a4) &gt; 0 else 'N' a5 = max(a5) if len(a5) &gt; 0 else 'N' print(a1, a2, a3, a4, a5)nums = list(map(int, input().split()))solution(nums[1:]) 1017 A除以B（20）本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。输入格式:输入在一行中依次给出 A 和 B，中间以 1 空格分隔。输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。输入样例： 1123456789050987654321 7 输出样例： 117636684150141093474 3 Solution: 1234567def solution(a, b): q = a // b r = a % b print(q, r)a, b = list(map(int, input().split()))solution(a, b) 1021 个位数统计 (15)给定一个k位整数N = dk-110^k-1^ + … + d110^1^ + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。输入格式：每个输入包含1个测试用例，即一个不超过1000位的正整数N。输出格式：对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。输入样例： 1100311 输出样例： 1230:21:33:1 Solution 1234567891011121314import operatordef solution(num): result = {} num = list(num) num.sort() for key in num: if key in result: result[key] += 1 else: result[key] = 1 for k,v in result.items(): print('{}:{}'.format(k,v))test = input()solution(test) 1023 组个最小数 (20)给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。输出格式：在一行中输出能够组成的最小的数。输入样例： 12 2 0 0 0 3 0 0 1 0 输出样例： 110015558 Solution 12345678def solution(counts): result = '' for i in range(1, 10): result += str(i) * counts[i] return result[0] + '0' * counts[0] + result[1:]counts = list(map(int, input().split(' ')))print(solution(counts)) 1031 查验身份证(15)一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：Z：0 1 2 3 4 5 6 7 8 9 10\\ M：1 0 X 9 8 7 6 5 4 3 2现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。输入格式：输入第一行给出正整数N（&lt;= 100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出“All passed”。输入样例1： 12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1： 12312010X19890101123411010819671130186637070419881216001X 输入样例2： 1232320124198808240056110108196711301862 输出样例2： 1All passed Solution 123456789101112131415161718192021def solution(ids): table = {0:'1', 1:'0', 2:'X', 3:'9', 4:'8', 5:'7', 6:'6', 7:'5', 8:'4', 9:'3', 10:'2'} weight = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] flag = True for id in ids: if not id[:17].isdigit(): print(id) flag = False continue weight_sum = 0 for i in range(17): weight_sum += int(id[i]) * weight[i] if table[weight_sum % 11] != id[17]: print(id) flag = False if (flag): print('All passed')count = int(input())data = [input() for i in range(count)]solution(data) 1037 在霍格沃茨找零钱（20）如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱P和他实付的钱A，你的任务是写一个程序来计算他应该被找的零钱。输入格式：输入在1行中分别给出P和A，格式为“Galleon.Sickle.Knut”，其间用1个空格分隔。这里Galleon是[0, 10^7^]区间内的整数，Sickle是[0, 17)区间内的整数，Knut是[0, 29)区间内的整数。输出格式：在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。输入样例1： 110.16.27 14.1.28 输出样例1： 13.2.1 输入样例2： 114.1.28 10.16.27 输出样例2： 1-3.2.1 Solution 12345678910111213141516171819def solution(p, a): # 1*Galleon--&gt;17*Sickle 1*Sickle--&gt;29*Knut # Galleon Sickle Knut p_knut = p[0] * 17 * 29 + p[1] * 29 + p[2] a_knut = a[0] * 17 * 29 + a[1] * 29 + a[2] change = a_knut - p_knut symbol = 1 if change &lt; 0: change = abs(change) symbol = -1 change_galleon = change // (17 * 29) change_sickle = change % (17 * 29) // 29 change_kunt = change % 29 print('{}.{}.{}'.format(change_galleon * symbol, change_sickle, change_kunt))pa = input().split()p = list(map(int, pa[0].split('.')))a = list(map(int, pa[1].split('.')))solution(p, a) 1038 统计同成绩学生(20)本题要求读入N名学生的成绩，将获得某一给定分数的学生人数输出。输入格式：输入在第1行给出不超过10^5^的正整数N，即学生总人数。随后1行给出N名学生的百分制整数成绩，中间以空格分隔。最后1行给出要查询的分数个数K（不超过N的正整数），随后是K个分数，中间以空格分隔。输出格式：在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。输入样例： 1231060 75 90 55 75 99 82 90 75 503 75 90 88 输出样例： 13 2 0 Solution 1234567891011def solution(grades, targets): result = {target:0 for target in targets} for grade in grades: if grade in result: result[grade] += 1 print(' '.join(map(str, [result[target] for target in targets])))input()grades = list(map(int, input().split()))targets = list(map(int, input().split()))solution(grades, targets[1:]) 1041 考试座位号(15)每个PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。输入格式：输入第一行给出一个正整数N（&lt;=1000），随后N行，每行给出一个考生的信息：“准考证号 试机座位号 考试座位号”。其中准考证号由14位数字组成，座位从1到N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。考生信息之后，给出一个正整数M（&lt;=N），随后一行中给出M个待查询的试机座位号码，以空格分隔。输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1个空格分隔。输入样例： 1234567410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例： 1210120150912002 210120150912119 1 Solution 12345678910111213def solution(datas, targets): for target in targets: if target in datas: print(datas[target])n = int(input())datas = {}for i in range(n): data = input().split() datas[data[1]] = data[0] + ' ' + data[2]input()targets = input().split()solution(datas, targets) 1042 字符统计(20)请编写程序，找出一段给定文字中出现最频繁的那个英文字母。输入格式：输入在一行中给出一个长度不超过1000的字符串。字符串由ASCII码表中任意可见字符及空格组成，至少包含1个英文字母，以回车结束（回车不算在内）。输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。输入样例： 1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例： 1e 7 Solution 1234567891011121314def solution(chars): statistical = {} for char in chars: if char.isalpha(): if char in statistical: statistical[char] += 1 else: statistical[char] = 1 # 传到key的值为元组，如:('e', 7) key = max(sorted(statistical.items()), key=lambda x:x[1]) print(key[0], key[1])chars = input().lower()solution(chars) 1046 划拳(15)划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。输入格式：输入第一行先给出一个正整数N（&lt;=100），随后N行，每行给出一轮划拳的记录，格式为：甲喊 甲划 乙喊 乙划其中“喊”是喊出的数字，“划”是划出的数字，均为不超过100的正整数（两只手一起划）。输出格式：在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。输入样例： 12345658 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 15 输出样例： 11 2 Solution 123456789101112131415161718def solution(records): first, second = 0, 0 for record in records: # 甲喊、乙喊、甲划、乙划 c1, c2, g1, g2 = record[0], record[2], record[1], record[3] if g1 == g2: continue elif c1 + c2 == g1: second += 1 elif c1 + c2 == g2: first += 1 print(first, second)n = int(input())records = []for i in range(n): records.append(list(map(int, input().split(' '))))solution(records) 1047 编程团体赛(20)编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。现给定所有队员的比赛成绩，请你编写程序找出冠军队。输入格式：输入第一行给出一个正整数N（&lt;=10000），即所有参赛队员总数。随后N行，每行给出一位队员的成绩，格式为：“队伍编号-队员编号 成绩”，其中“队伍编号”为1到1000的正整数，“队员编号”为1到10的正整数，“成绩”为0到100的整数。输出格式：在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。输入样例： 123456763-10 9911-5 87102-1 0102-3 10011-9 893-2 61 输出样例： 111 176 Solution 123456789101112131415def solution(scores): statistical_scores = {} for score in scores: if score[0] in statistical_scores: statistical_scores[score[0]] += int(score[2]) else: statistical_scores[score[0]] = int(score[2]) team_score = max(statistical_scores.items(), key=lambda x:x[1]) print(team_score[0], team_score[1])n = int(input())scores = []for i in range(n): scores.append(input().replace('-', ' ').split())solution(scores) 1053 住房空置率（20）在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下： 在观察期内，若存在超过一半的日子用电量低于某给定的阈值 e，则该住房为“可能空置”； 若观察期超过某给定阈值 D 天，且满足上一个条件，则该住房为“空置”。现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。 输入格式：输入第一行给出正整数 N（≤1000），为居民区住房总套数；正实数 e，即低电量阈值；正整数 D，即观察期阈值。随后 N 行，每行按以下格式给出一套住房的用电量数据：K E1 E2 … EK其中 K 为观察的天数，Ei 为第 i 天的用电量。输出格式：在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。输入样例： 1234565 0.5 106 0.3 0.4 0.5 0.2 0.8 0.610 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.111 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 输出样例： 140.0% 20.0% （样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。）Solution 12345678910111213141516171819def solution(n, e, d, dates, consumptions): count_maybe, count_must = 0, 0 for i in range(n): consumption = consumptions[i] if len(list(filter(lambda x: x &lt; e, consumption))) &gt; len(consumption) / 2: count_maybe += 1 if dates[i] &gt; d: count_must += 1 count_maybe -= 1 print('{}% {}%'.format(round(count_maybe / n * 100, 1), round(count_must / n * 100, 1)))n, e, d = input().split()n, e, d = int(n), float(e), int(d)dates, consumptions = [], []for i in range(n): data = input().split() dates.append(int(data[0])) consumptions.append(list(map(float, data[1:])))solution(n, e, d, dates, consumptions)","link":"/arithmetic/pat/history/"},{"title":"MySQL","text":"There is recorded some MySQL operation. Windows下连接和启动MySQL mysql -u root -p 将MySql的安装目录下的bin目录设置到PATH环境变量下，打开CMD就能直接连接MySQL了。CMD输入mysql -u root -p，root为用户名，回车后输入密码即可进入到MySQL命令行模式 net start mysql57 运行管理员权限的CMD，输入命令即可启动MySQL net stop mysql57 运行管理员权限的CMD，输入命令即可关闭MySQL 本文使用的部分单词说明 db_name：数据库名称 table_name：数据表名称 old_name：要修改的字段的名称 new_name：要修改字段的新名称 column_name：列的名称 type：类型和范围，例如：varchar(2) view_name：视图名称 数据库命令行操作 显示现有数据库 show databases; 12345678910111213mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || fruitdb || mysql || performance_schema || sys || test || wehelp_test |+--------------------+7 rows in set (0.01 sec) 新建数据库 create database db_name; 12mysql&gt; create database fruitsb;Query OK, 1 row affected (0.00 sec) 新建指定字符集类型数据库 create database db_name character set utf8; 12mysql&gt; create database test1 character set utf8;Query OK, 1 row affected (0.00 sec) 删除数据库 drop database db_name; 12mysql&gt; drop database fruitsb;Query OK, 0 rows affected (0.00 sec) 修改数据库字符集 alter database db_name character set utf8; 12mysql&gt; alter database test1 character set utf8;Query OK, 1 row affected (0.00 sec) 切换当前使用的数据库 use db_name; 12mysql&gt; use test1;Database changed 显示数据库的创建语句 show create table table_name; 1234567891011mysql&gt; show create table SCORE;+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| SCORE | CREATE TABLE `SCORE` (`SNO` varchar(3) NOT NULL,`CNO` varchar(5) NOT NULL,`DEGREE` decimal(10,1) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 修改密码 123mysql -uroot -pupdate user set authentication_string=password(\"123456\") where User='root';flush privileges; 数据表命令行操作 创建数据表 12345use my_testcreate table test(id int auto_increment primary key,age int); Query OK, 0 rows affected (0.02 sec) 显示当前数据库的所有数据表 show tables; 12345678mysql&gt; show tables;+-----------------+| Tables_in_test1 |+-----------------+| test || test2 |+-----------------+2 rows in set (0.00 sec) 显示数据表结构 desc table_name; 12345678mysql&gt; desc test;+-------+---------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+----------------+| name | int(11) | NO | PRI | NULL | auto_increment || age | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+----------------+2 rows in set (0.01 sec) 添加字段 alter table table_name add column_name type; 123mysql&gt; alter table test add sex int(2);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 删除字段 alter table table_name drop column_name; 123456789101112mysql&gt; alter table test drop sex;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc test;+-------+---------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+----------------+| name | int(11) | NO | PRI | NULL | auto_increment || age | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+----------------+2 rows in set (0.00 sec) 修改字段 alter table table_name modify column_name type; 123mysql&gt; alter table test modify age varchar(2);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 修改字段名称 alter table table_name change column old_name new_name type; 123456789101112mysql&gt; alter table test change column name id int;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc test;+-------+------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || age | varchar(2) | YES | | NULL | |+-------+------------+------+-----+---------+-------+2 rows in set (0.00 sec) 修改表名 12345678910mysql&gt; ALTER TABLE T_TEST RENAME TO TT;Query OK, 0 rows affected (0.02 sec)mysql&gt; SHOW TABLES;+----------------+| Tables_in_test |+----------------+| TT |+----------------+1 row in set (0.00 sec) SELECT语句 查询所有数据：select * from table_name; 123456789mysql&gt; select * from test;+----+------+| id | age |+----+------+| 1 | 男 || 2 | 女 || 3 | 中 |+----+------+3 rows in set (0.00 sec) 查询指定列数据：select column_name1, column_name2, ..., column_nameN from table_name; 123456789mysql&gt; select age from test;+------+| age |+------+| 男 || 女 || 中 |+------+3 rows in set (0.00 sec) INSERT语句 添加数据行 insert into table_name values(value1, value2, ..., valueN); insert into table_name(column_name1, column_name2, ..., column_nameN) values(value1, value2, ..., valueN); 12345678910111213mysql&gt; insert into test(id,age) value(4,'未知');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test;+----+--------+| id | age |+----+--------+| 1 | 男 || 2 | 女 || 3 | 中 || 4 | 未知 |+----+--------+4 rows in set (0.00 sec) 添加多条数据 insert into table_name(column_name1, column_name2, ..., column_nameN) values(value1, value2, ..., valueN), (value1, value2, ..., valueN), ..., (value1, value2, ..., valueN); 12345678910111213mysql&gt; insert into test value(1,'男'),(2,'女'),(3,'中');Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from test;+----+------+| id | age |+----+------+| 1 | 男 || 2 | 女 || 3 | 中 |+----+------+3 rows in set (0.00 sec) WHERE子句可用于SELECT、UPDATE、DELETE语句，可以使用AND或者OR指定一个或多个条件来自（图片来自菜鸟教程） 指定查询的参数值：select * from table_name where column_name=value; 1234567mysql&gt; select * from test where age='未知';+----+--------+| id | age |+----+--------+| 4 | 未知 |+----+--------+1 row in set (0.00 sec) 多条件指定查询：select * from table_name [where condition1 [and [or]] condition2.....; 12345678mysql&gt; select * from test where id &gt; 2 and id &lt; 5;+----+--------+| id | age |+----+--------+| 3 | 中 || 4 | 未知 |+----+--------+2 rows in set (0.00 sec) UPDATE语句如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。. 语法 UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 示例： 1234567891011121314mysql&gt; update test set age='xx' where id=2;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from test;+----+--------+| id | age |+----+--------+| 1 | 男 || 2 | xx || 3 | 中 || 4 | 未知 |+----+--------+4 rows in set (0.00 sec) DELETE语句删除数据的通用语法：delete from table_name [where Clause]; 删除一条数据示例 123456789101112mysql&gt; delete from test where id=2;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from test;+----+--------+| id | age |+----+--------+| 1 | 男 || 3 | 中 || 4 | 未知 |+----+--------+3 rows in set (0.00 sec) LIKE子句 可以用来做模糊查询 语法 以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法： 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' 你可以在 WHERE 子句中指定任何条件 你可以在 WHERE 子句中使用LIKE子句 你可以使用LIKE子句代替等号 = LIKE 通常与 % 一同使用，类似于一个元字符的搜索 你可以使用 AND 或者 OR 指定一个或多个条件 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件 使用’__’指定位数进行精确查询，一个下划线代表一位（本段内容来自菜鸟教程) 使用示例： 12345678# 查询age字段中以‘知’结尾的数据行mysql&gt; select * from test where age like '%知';+----+--------+| id | age |+----+--------+| 4 | 未知 |+----+--------+1 row in set (0.00 sec) 精确查询示例： 12345678# 查询name字段中以Tom开头后面还有4个字符的数据行mysql&gt; select * from test where name like 'Tom____';+------+------+---------+| id | age | name |+------+------+---------+| 3 | 24 | TomCook |+------+------+---------+1 row in set (0.00 sec) ORDER BY子句当我们需对读取的数据进行排序就可以使用ORDER BY子句 语法 以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据： 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。（本段内容来自菜鸟教程） 使用示例： 123456789mysql&gt; select * from test order by id desc;+----+--------+| id | age |+----+--------+| 4 | 未知 || 3 | 中 || 1 | 男 |+----+--------+3 rows in set (0.00 sec) GROUP BY语句GROUP BY语句根据一个或多个列对结果集进行分组 语法 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; （本段内容来自菜鸟教程） 使用示例： 12345678910111213141516171819202122232425mysql&gt; select * from test;+----+--------+| id | age |+----+--------+| 1 | 男 || 3 | 中 || 4 | 未知 || 7 | a || 8 | a || 9 | b || 10 | 男 |+----+--------+7 rows in set (0.00 sec)mysql&gt; select age from test group by age;+--------+| age |+--------+| a || b || 中 || 未知 || 男 |+--------+5 rows in set (0.00 sec) BETWEEN语句 BETWEEN是闭区间x BETWEEN 3 AND 4 (3 &lt;= x &lt;= 4) 语法：where column_name between value1 and value2、where column_name not between value1 and value2 示例： 123456789101112mysql&gt; select * from test where id between 2 and 10;+----+--------+| id | age |+----+--------+| 3 | 中 || 4 | 未知 || 7 | a || 8 | a || 9 | b || 10 | 男 |+----+--------+6 rows in set (0.00 sec) 内置方法 floor 向下取整 round 四舍五入 ceil 向上取整 视图 创建视图 CREATE VIEW VIEW_NAME AS SELECT COLUMN_NAME1,COLUMN_NAME2... FROM TABLE_NAME; 12mysql&gt; CREATE VIEW V_SCORE AS SELECT * FROM SCORE;Query OK, 0 rows affected (0.03 sec) 读取视图数据 SELECT COLUMN_NAME1,COLUMN_NAME2... FROM VIEW_NAME; 123456789101112131415161718mysql&gt; SELECT * FROM V_SCORE;+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-245 | 86.0 || 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 103 | 3-105 | 92.0 || 105 | 3-105 | 88.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 107 | 3-105 | 91.0 || 108 | 3-105 | 78.0 || 101 | 6-166 | 85.0 || 107 | 6-106 | 79.0 || 108 | 6-166 | 81.0 |+-----+-------+--------+12 rows in set (0.00 sec) 别名创建视图 CREATE VIEW VIEW_NAME (ALIAS_NAME1, ALIAS_NAME2...) AS SELECT COLUMN_NAME1, COLUMN_NAME2... FROM TABLE_NAME; 123456789101112131415mysql&gt; CREATE VIEW V_STUDENT(NAME, SEX) AS SELECT SNAME, SSEX FROM STUDENT;Query OK, 0 rows affected (0.02 sec)mysql&gt; SELECT * FROM V_STUDENT;+--------+-----+| NAME | SEX |+--------+-----+| 曾华 | 男 || 匡明 | 男 || 王丽 | 女 || 李军 | 男 || 王芳 | 女 || 陆君 | 男 |+--------+-----+6 rows in set (0.00 sec) 视图修改 修改视图数据会影响主表数据，因为视图数据就是从主表读取的，修改视图数据相当于直接修改主表 CREATE OR REPLACE VIEW VIEW_NAME (COLUMN_NAME1, COLUMN_NAME2...) AS SELECT COLUMN_NAME1, COLUMN_NAME2... FROM TABLE_NAME; 123456789101112131415161718192021mysql&gt; CREATE OR REPLACE VIEW V_SCORE (SNO, CNO) AS SELECT SNO, CNO FROM SCORE;Query OK, 0 rows affected (0.02 sec)mysql&gt; SELECT * FROM V_SCORE;+-----+-------+| SNO | CNO |+-----+-------+| 103 | 3-245 || 105 | 3-245 || 109 | 3-245 || 103 | 3-105 || 105 | 3-105 || 109 | 3-105 || 101 | 3-105 || 107 | 3-105 || 108 | 3-105 || 101 | 6-166 || 107 | 6-106 || 108 | 6-166 |+-----+-------+12 rows in set (0.00 sec) 删除视图 DROP VIEW VIEW_NAME 12mysql&gt; DROP VIEW V_SCORE;Query OK, 0 rows affected (0.00 sec) 显示视图详情 DESC VIEW_NAME; 123456789mysql&gt; DESC V_SCORE;+--------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+---------------+------+-----+---------+-------+| SNO | varchar(3) | NO | | NULL | || CNO | varchar(5) | NO | | NULL | || DEGREE | decimal(10,1) | NO | | NULL | |+--------+---------------+------+-----+---------+-------+3 rows in set (0.00 sec) MySQL执行语句返回结果FOUND_ROWS()FOUND_ROWS()函数可以返回查询到的记录数目A SELECT statement may include a LIMIT clause to restrict the number of rows the server returns to the client. In some cases, it is desirable to know how many rows the statement would have returned without the LIMIT, but without running the statement again. To obtain this row count, include an SQL_CALC_FOUND_ROWS option in the SELECT statement, and then invoke FOUND_ROWS() afterward 123mysql&gt; SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name-&gt; WHERE id &gt; 100 LIMIT 10;mysql&gt; SELECT FOUND_ROWS(); Example 123456789101112131415161718mysql&gt; select * from t_fruits;+----+------------+-------+-------+--------+| id | name | price | count | remark |+----+------------+-------+-------+--------+| 2 | orange | 2.0 | 2 | 橙子 || 3 | watermelon | 3.0 | 3 | 西瓜 || 4 | longan | 4.0 | 4 | 龙眼 || 5 | kiwis | 2.2 | 100 | |+----+------------+-------+-------+--------+4 rows in set (0.00 sec)mysql&gt; select FOUND_ROWS();+--------------+| FOUND_ROWS() |+--------------+| 4 |+--------------+1 row in set (0.00 sec) ROW_COUNT()ROW_COUNT()函数可以返回受到影响的行数 DDL statements: 0. This applies to statements such as CREATE TABLE or DROP TABLE. DML statements other than SELECT: The number of affected rows. This applies to statements such as UPDATE, INSERT, or DELETE (as before), but now also to statements such as ALTER TABLE and LOAD DATA INFILE( SELECT: -1 if the statement returns a result set, or the number of rows “affected” if it does not. For example, for SELECT * FROM t1, ROW_COUNT() returns -1. For SELECT * FROM t1 INTO OUTFILE '*file_name*', ROW_COUNT() returns the number of rows written to the file. SIGNAL statements: 0 Example 12345678910111213141516171819202122mysql&gt; INSERT INTO t VALUES(1),(2),(3);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT ROW_COUNT();+-------------+| ROW_COUNT() |+-------------+| 3 |+-------------+1 row in set (0.00 sec)mysql&gt; DELETE FROM t WHERE i IN(1,2);Query OK, 2 rows affected (0.00 sec)mysql&gt; SELECT ROW_COUNT();+-------------+| ROW_COUNT() |+-------------+| 2 |+-------------+1 row in set (0.00 sec) 本节内容英语说明来自官方文档","link":"/database/mysql/mysql/"},{"title":"Redis","text":"Redis operation. 安装(Windows)下载地址:https://github.com/MSOpenTech/redis/releases解压后将文件夹路径配置到PATH环境变量，就可以在CMD窗口直接使用命令了 安装(Debian)下载1wget http://download.redis.io/releases/redis-4.0.11.tar.gz 解压、安装1234tar xzf redis-4.0.11.tar.gzcd redis-4.0.11makemake install 创建配置和持久化目录12mkdir /etc/redismkdir -p /var/redis/6379 配置 使用Redis的配置模板，将redis-4.0.11目录下的配置模板拷贝到/etc/redis下，配置文件名以要使用的端口号命名 1cp redis.conf /etc/redis/6379.conf 开启守护线程，使Redis开启后可以在后台运行，不同另开窗口使用 1vim /etc/redis/6379.conf 将daemonize no修改为daemonize yes 设置持久化文件存储位置，6379为该配置使用的端口 配置dir为dir /var/redis/6379 将Redis配置为系统服务 在redis-4.0.11/utils目录下有个redis_init_script文件，将该文件拷贝到/etc/init.d文件夹下 12cd utilscp redis_init_script /etc/init.d/redis_6379 重新加载配置文件 1systemctl daemon-reload 启用Redis 1systemctl start redis_6379 停止服务 1systemctl stop redis_6379 重启服务 1systemctl restart redis_6379 其他命令设置密码后Redis无法正常关闭时的关闭方法1redis-cli -p 6379 -a password shutdown 中文教程http://www.redis.net.cn/tutorial/3501.html 命令(CMD下) 启动 redis-server 使用配置文件启动 redis-server redis.conf redis.conf为要使用的配置文件 启动Redis客户端 redis-cli 远程启动Redis客户端 redis-cli -h host -p port -a password 如:redis-cli -h 127.0.0.1 -p 6379 -a 12345678 命令(Redis客户端下) auth password 进入redis-cli后，使用此命令进行密码校验（如果有密码的话） 设置连接密码 config set requirepass 12345678 获取连接密码 config get requirepass 获取数据库中key的数量 dbsize 添加key，value set key value 获取value get key 删除key del key 获取全部key keys * 查看key的类型 type key 随机取出一个key randomkey 清空Redis flushdb 查看该元素是否存在 exists key Python下使用Redis连接12345app.redis = redis.Redis(host=constants.REDIS_HOST,port=constants.REDIS_PORT,db=constants.REDIS_DB,password=constants.REDIS_PASSWORD) 添加key,value1app.redis.set('smileorigin', 'testvalue') 获取value1app.redis.get('smileorigin') 数据类型Stringstring是Redis最基本的类型，你可以理解成与一个key对应一个valuestring类型是二进制安全的，意思是Redis的string可以包含任何数据，比如jpg图片或者序列化的对象string类型是Redis最基本的数据类型，一个键最大能存储512MB 1234127.0.0.1:6379&gt; set xiaoyu sbOK127.0.0.1:6379&gt; get xiaoyu \"sb\" xiaoyu 就是键，sb 就是值一个键最大能存储512MB HashRedis hash是一个键值（key==&gt;value）对集合Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象 123456127.0.0.1:6379&gt; hmset smilehash xiaoyu sb xiaojie beautifulOK127.0.0.1:6379&gt; hget smilehash xiaoyu\"sb\"127.0.0.1:6379&gt; hget smilehash xiaojie\"beautiful\" smilehash为hash对集合的名称，xiaoyu、xiaojie为键，“sb”、“beautiful”为对应的值每个hash可以存储2的32次方减1个键值对（40多亿） ListRedis列表是简单的字符串的列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 1234567891011121314127.0.0.1:6379&gt; lpush smile origin(integer) 1127.0.0.1:6379&gt; lpush smile xiaoyang(integer) 2127.0.0.1:6379&gt; lpush smile dayang(integer) 3127.0.0.1:6379&gt; lrange smile 0 21) \"dayang\"2) \"xiaoyang\"3) \"origin\"127.0.0.1:6379&gt; lrange smile 0 101) \"dayang\"2) \"xiaoyang\"3) \"origin\" 列表最多可存储2的32次方减1个元素（每个列表可存储40多亿） Set（集合）Redis的Set是string类型的无序集合，集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)添加一个string元素到key对应的set集合中，成功返回2，如果元素已经存在返回0，不存在则返回错误 12345678127.0.0.1:6379&gt; sadd testset 1(integer) 1127.0.0.1:6379&gt; smembers testset1) \"1\"127.0.0.1:6379&gt; sadd testset 1(integer) 0127.0.0.1:6379&gt; smembers testset1) \"1\" testset添加命令执行了两次，但是第一次返回1表示操作成功添加了testset，第二次返回0元素已存在不在重复添加集合最多可存储2的32次方减1个成员（每个集合可存储40多亿个成员） zset（sorted set：有序集合）Redis zset和set一样也是string类型元素的集合，且不允许重复成员，不同的是每个元素都会关联一个double类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但是分数（score）却可以重复 123456789101112127.0.0.1:6379&gt; zadd test_zset 1 a(integer) 1127.0.0.1:6379&gt; zadd test_zset 1.1 b(integer) 1127.0.0.1:6379&gt; zadd test_zset 1.1 b(integer) 0127.0.0.1:6379&gt; zadd test_zset 1.2 g(integer) 1127.0.0.1:6379&gt; zrangebyscore test_zset 0 101) \"a\"2) \"b\"3) \"g\" 各个数据类型应用场景 类型 简介 特性 场景 String（字符串） 二进制安全 可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512M Hash（字典） 键值对集合，即编程语言中的Map类型 适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值 存储、读取、修改用户属性 list（列表） 链表（双向链表） 增删快，提供了操作某一段元素的API 1.最新消息排行等功能（比如朋友圈的时间线） 2.消息队列 Set（集合） 哈希表实现，元素不重复 1.添加、删除、查找的复杂度都是O(1) 2.为集合提供了求交集、并集、差集等操作 1.共同好友 2.利用唯一性统计访问网站的所有独立ip 3.好友推荐时，根据tag求交集，大于某个阈值就可以推荐 Sorted Set（有序集合） 将Set中的元素增加一个权重参数score，元素按score有序排列 数据插入集合时，已经进行天然排序 1.排行榜 2.带权重的消息队列L Redis在Center os服务器中无法被外部访问出现此情况可能是服务器的防火墙开启了，且未设置Redis的端口为白名单，所以外部访问被拒绝，且4.0版本后的Redis要记得在配置文件中设置密码，否则为了安全默认是禁止外部连接的使用以下命令将Redis使用的6379端口设置为列外 12firewall-cmd --zone=public --add-port=6379/tcp --permanent firewall-cmd --reload","link":"/database/redis/redis/"},{"title":"Stored Procedure","text":"There is recorded something of MySQL stored procedure. Reference本文大部分参考自以下文章：https://www.cnblogs.com/mark-chan/p/5384139.html仅做个人笔记使用 什么是存储过程？一组可编程的函数，是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行存储过程可以用来封装特定功能，以便应用于不同的平台，可以看做对面向对象编程的模拟 存储过程的优点 增强SQL语言的功能和灵活性 存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算 标准组件式编程 存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句 数据库管理人员可随时对存储过程进行修改，对应用程序源代码毫无影响 较快的执行速度 如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理执行速度快很多，因为存储过程是预编译的。在首次运行一个存储过程时查询优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transation-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些 减少网络流量 针对同一个数据库对象的操作（如：查询、修改），如果这一操作所涉及的Transation-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载 作为一种安全机制来充分利用 通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全 Create语法1234567DELIMITER //CREATE PROCEDURE PROCEDURE_NAME([[IN | OUT | INOUT] ARG_NAME TYPE [, [INT | OUT | INOUT] ARG_NAME TYPE...]])BEGINPROCEDURE BODYEND//DELIMITER ; 分隔符MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要先用“DELIMITER //”声明当前段分隔符，让编译器把两个“//“之间的内容当做存储过程的代码，不会执行这些代码，“DELIMITER ;”意为把分隔符还原 参数存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用“,”分隔开。MySQL存储过程的参数用在存储过程的定义，共有三种类型：IN、OUT、INOUT IN 参数的值必须在调用存储过程前指定，在存储过程中修改该参数的值不能被返回 即类似JAVA中的值传递，传递的相当于参数的值得拷贝，而不是参数本身 OUT 该值可在存储过程内部被改变，并可返回，未在存储过程中赋值的话，则在存储过程中值为空 即类似JAVA中的引用传递，传递的是该参数本身的地址，该参数在存储过程中被修改相当于直接修改该参数本身 INOUT 具备IN、OUT的特性，在调用时指定，并可被改变和返回 过程体（PROCEDURE BODY） 过程体的开始与结束使用BEGIN和END进行标识 IN示例12345678910111213141516171819202122232425262728293031323334353637mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE in_param(IN p_in int)-&gt; BEGIN-&gt; SELECT p_in;-&gt; SET p_in=2;-&gt; SELECT p_in;-&gt; END;-&gt; //Query OK, 0 rows affected (0.01 sec)mysql&gt; SET @p_in=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL in_param(@p_in);+------+| p_in |+------+| 1 |+------+1 row in set (0.00 sec)+------+| p_in |+------+| 2 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @p_in;+-------+| @p_in |+-------+| 1 |+-------+1 row in set (0.00 sec) 从运行结果可以得出，p_in虽然在存储过程中被修改了，但并不影响存储过程外的@p_in的值 OUT示例1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE out_param(OUT p_out int)-&gt; BEGIN-&gt; SELECT p_out;-&gt; SET p_out=2;-&gt; SELECT p_out;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; SET @p_out=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL out_param(@p_out);+-------+| p_out |+-------+| NULL |+-------+1 row in set (0.00 sec)+-------+| p_out |+-------+| 2 |+-------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @p_out;+--------+| @p_out |+--------+| 2 |+--------+1 row in set (0.00 sec) 从运行结果可以得出，p_out在存储过程中没被赋值的情况下是读取不到数据的，赋值后再存储过程外的@p_out的值也被修改了 INOUT示例1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE inout_param(inout p_inout int)-&gt; BEGIN-&gt; SELECT p_inout;-&gt; SET p_inout=2;-&gt; SELECT p_inout;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; SET @p_inout=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL inout_param(@p_inout);+---------+| p_inout |+---------+| 1 |+---------+1 row in set (0.00 sec)+---------+| p_inout |+---------+| 2 |+---------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @p_inout;+----------+| @p_inout |+----------+| 2 |+----------+1 row in set (0.00 sec) 从运行结果可以得出，inout参数结合了in和out的特点，传进去的参数既可以读取又可以修改 删除存储过程 语法 DROP PROCEDURE PROCEDURE_NAME; Example 12mysql&gt; DROP PROCEDURE p;Query OK, 0 rows affected (0.01 sec) 局部变量DECLARE之前不能调用语句 语法 DECLARE FIELD_NAME TYPE; 赋值 SET FIELD_NAME=VALUE; 实例 123456789101112131415161718192021222324252627282930mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE p()-&gt; BEGIN-&gt; DECLARE d INT;-&gt; SET @d=111;-&gt; SELECT @d;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; CALL p;+------+| @d |+------+| 111 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL p();+------+| @d |+------+| 111 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 数值类型（图片来自菜鸟教程） 日期和时间类型（图片来自菜鸟教程） 字符串类型（图片来自菜鸟教程） 用户变量用户变量一般以@开头，如果滥用用户变量会导致程序难以理解以及管理实例 12345678910111213141516171819202122232425262728293031323334# 创建用户变量方式1mysql&gt; SELECT 'HELLO WORLD!' INTO @X;Query OK, 1 row affected (0.00 sec)mysql&gt; SELECT @X;+--------------+| @X |+--------------+| HELLO WORLD! |+--------------+1 row in set (0.00 sec)# 创建用户变量方式2mysql&gt; SET @y=12;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @y;+------+| @y |+------+| 12 |+------+1 row in set (0.00 sec)mysql&gt; SET @y=1+2+3+4*5;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @y;+------+| @y |+------+| 26 |+------+1 row in set (0.00 sec) 在存储过程中使用用户变量 123456789101112131415161718192021mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE p()-&gt; BEGIN-&gt; SELECT @global;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; SET @global=12345;Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL p();+---------+| @global |+---------+| 12345 |+---------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 控制语句if…[then…]elseif…else12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; DROP PROCEDURE IF EXISTS pro_if;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE pro_if(IN type INT) -&gt; BEGIN -&gt; DECLARE c VARCHAR(500); -&gt; IF type = 0 THEN SET c = 'PARAM IS 0'; -&gt; ELSEIF type = 1 THEN SET c = 'PARAM IS 1'; -&gt; ELSE SET c = 'PARAM IS OTHERS'; -&gt; END IF;-&gt; END;-&gt; //Query OK, 0 rows affected (0.01 sec)mysql&gt; DELIMITER ;mysql&gt; CALL pro_if(0);+------------+| c |+------------+| PARAM IS 0 |+------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL pro_if(1);+------------+| c |+------------+| PARAM IS 1 |+------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL pro_if(2);+-----------------+| c |+-----------------+| PARAM IS OTHERS |+-----------------+1 row in set (0.01 sec)Query OK, 0 rows affected (0.01 sec) case…when1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE proc_case(type int)-&gt; BEGIN-&gt; DECLARE c VARCHAR(500);-&gt; case type-&gt; WHEN 0 THEN SET c = 'PARAM IS 0';-&gt; WHEN 1 THEN SET c = 'PARAM IS 1';-&gt; WHEN 2 THEN SET c = 'PARAM IS 2';-&gt; ELSE SET c = 'PARAM IS OTHERS';-&gt; SELECT c;-&gt; END CASE;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; CALL proc_case(0);+------------+| c |+------------+| PARAM IS 0 |+------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL proc_case(1);+------------+| c |+------------+| PARAM IS 1 |+------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL proc_case(2);+------------+| c |+------------+| PARAM IS 2 |+------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL proc_case(3);+-----------------+| c |+-----------------+| PARAM IS OTHERS |+-----------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) while123456789101112131415161718192021222324252627282930313233343536mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE proc_while(IN n INT)-&gt; BEGIN-&gt; DECLARE i INT;-&gt; DECLARE s INT;-&gt; SET i=0;-&gt; SET s=0;-&gt; WHILE i&lt;=n DO-&gt; SET s = s + i;-&gt; SET i = i + 1;-&gt; END WHILE;-&gt; SELECT s;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; CALL proc_while(2);+------+| s |+------+| 3 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL proc_while(12);+------+| s |+------+| 78 |+------+1 row in set (0.01 sec)Query OK, 0 rows affected (0.01 sec) loop1234567891011121314151617181920212223242526272829303132mysql&gt; DROP PROCEDURE IF EXISTS proc_loop;Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE proc_loop(IN n INT)-&gt; BEGIN-&gt; DECLARE i INT;-&gt; DECLARE s INT;-&gt; SET i=0;-&gt; SET s=0;-&gt; LOOP_LABEL:LOOP-&gt; SET s = s + i;-&gt; SET i = i + 1;-&gt; IF i &gt; 10 THEN LEAVE LOOP_LABEL;-&gt; END IF;-&gt; END LOOP;-&gt; SELECT s;-&gt; END;-&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER ;mysql&gt; CALL proc_loop(2);+------+| s |+------+| 55 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) repeat…end repeat123456789101112131415161718192021222324252627282930mysql&gt; DROP PROCEDURE IF EXISTS proc_repeat;Query OK, 0 rows affected (0.00 sec)mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE proc_repeat(IN n INT) -&gt; BEGIN -&gt; DECLARE i INT; -&gt; DECLARE s INT; -&gt; SET i=0; -&gt; SET s=0; -&gt; REPEAT -&gt; SET s = s + i; -&gt; SET i = i + 1; -&gt; UNTIL i&gt;10 -&gt; END REPEAT; -&gt; SELECT s; -&gt; END;-&gt; //Query OK, 0 rows affected (0.01 sec)mysql&gt; DELIMITER ;mysql&gt; CALL proc_repeat(2);+------+| s |+------+| 55 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)","link":"/database/mysql/stored-procedure/"},{"title":"MySQL练习","text":"There is recorded some MySQL pratices. 数据库和数据准备 数据库建立123456789101112131415161718192021222324252627282930 CREATE TABLE STUDENT (SNO VARCHAR(3) NOT NULL,SNAME VARCHAR(4) NOT NULL,SSEX VARCHAR(2) NOT NULL,SBIRTHDAY DATETIME,CLASS VARCHAR(5) ); CREATE TABLE COURSE (CNO VARCHAR(5) NOT NULL,CNAME VARCHAR(10) NOT NULL,TNO VARCHAR(10) NOT NULL ); CREATE TABLE SCORE (SNO VARCHAR(3) NOT NULL,CNO VARCHAR(5) NOT NULL,DEGREE NUMERIC(10, 1) NOT NULL ); CREATE TABLE TEACHER (TNO VARCHAR(3) NOT NULL,TNAME VARCHAR(4) NOT NULL, TSEX VARCHAR(2) NOT NULL,TBIRTHDAY DATETIME NOT NULL, PROF VARCHAR(6),DEPART VARCHAR(10) NOT NULL ); 数据填充1234567891011121314151617181920212223242526272829INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (108 ,'曾华' ,'男' ,'1977-09-01',95033);INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (105 ,'匡明' ,'男' ,'1975-10-02',95031);INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (107 ,'王丽' ,'女' ,'1976-01-23',95033);INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (101 ,'李军' ,'男' ,'1976-02-20',95033);INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (109 ,'王芳' ,'女' ,'1975-02-10',95031);INSERT INTO STUDENT (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (103 ,'陆君' ,'男' ,'1974-06-03',95031);INSERT INTO COURSE(CNO,CNAME,TNO)VALUES ('3-105' ,'计算机导论',825);INSERT INTO COURSE(CNO,CNAME,TNO)VALUES ('3-245' ,'操作系统' ,804);INSERT INTO COURSE(CNO,CNAME,TNO)VALUES ('6-166' ,'数据电路' ,856);INSERT INTO COURSE(CNO,CNAME,TNO)VALUES ('9-888' ,'高等数学' ,100);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (103,'3-245',86);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (105,'3-245',75);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (109,'3-245',68);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (103,'3-105',92);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (105,'3-105',88);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (109,'3-105',76);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (101,'3-105',64);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (107,'3-105',91);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (108,'3-105',78);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (101,'6-166',85);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (107,'6-106',79);INSERT INTO SCORE(SNO,CNO,DEGREE)VALUES (108,'6-166',81);INSERT INTO TEACHER(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (804,'李诚','男','1958-12-02','副教授','计算机系');INSERT INTO TEACHER(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (856,'张旭','男','1969-03-12','讲师','电子工程系');INSERT INTO TEACHER(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (825,'王萍','女','1972-05-05','助教','计算机系');INSERT INTO TEACHER(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (831,'刘冰','女','1977-08-14','助教','电子工程系'); 数据填充完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mysql&gt; SELECT * FROM STUDENT;+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 108 | 曾华 | 男 | 1977-09-01 00:00:00 | 95033 || 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 101 | 李军 | 男 | 1976-02-20 00:00:00 | 95033 || 109 | 王芳 | 女 | 1975-02-10 00:00:00 | 95031 || 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 |+-----+--------+------+---------------------+-------+6 rows in set (0.00 sec)mysql&gt; SELECT * FROM COURSE;+-------+-----------------+-----+| CNO | CNAME | TNO |+-------+-----------------+-----+| 3-105 | 计算机导论 | 825 || 3-245 | 操作系统 | 804 || 6-166 | 数据电路 | 856 || 9-888 | 高等数学 | 100 |+-------+-----------------+-----+4 rows in set (0.00 sec)mysql&gt; SELECT * FROM SCORE;+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-245 | 86.0 || 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 103 | 3-105 | 92.0 || 105 | 3-105 | 88.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 107 | 3-105 | 91.0 || 108 | 3-105 | 78.0 || 101 | 6-166 | 85.0 || 107 | 6-106 | 79.0 || 108 | 6-166 | 81.0 |+-----+-------+--------+12 rows in set (0.00 sec)mysql&gt; SELECT * FROM TEACHER;+-----+--------+------+---------------------+-----------+-----------------+| TNO | TNAME | TSEX | TBIRTHDAY | PROF | DEPART |+-----+--------+------+---------------------+-----------+-----------------+| 804 | 李诚 | 男 | 1958-12-02 00:00:00 | 副教授 | 计算机系 || 856 | 张旭 | 男 | 1969-03-12 00:00:00 | 讲师 | 电子工程系 || 825 | 王萍 | 女 | 1972-05-05 00:00:00 | 助教 | 计算机系 || 831 | 刘冰 | 女 | 1977-08-14 00:00:00 | 助教 | 电子工程系 |+-----+--------+------+---------------------+-----------+-----------------+4 rows in set (0.00 sec) 题目查询STUDENT表中的所有记录的SNAME、SSEX和CLASS列123456789101112mysql&gt; SELECT SNAME, SSEX, CLASS FROM STUDENT;+--------+------+-------+| SNAME | SSEX | CLASS |+--------+------+-------+| 曾华 | 男 | 95033 || 匡明 | 男 | 95031 || 王丽 | 女 | 95033 || 李军 | 男 | 95033 || 王芳 | 女 | 95031 || 陆君 | 男 | 95031 |+--------+------+-------+6 rows in set (0.00 sec) 查询教师所有的单位即不重复的DEPART列12345678mysql&gt; SELECT DEPART FROM TEACHER GROUP BY DEPART;+-----------------+| DEPART |+-----------------+| 电子工程系 || 计算机系 |+-----------------+2 rows in set (0.00 sec) 查询STUDENT表的所有记录123456789101112mysql&gt; SELECT * FROM STUDENT;+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 108 | 曾华 | 男 | 1977-09-01 00:00:00 | 95033 || 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 101 | 李军 | 男 | 1976-02-20 00:00:00 | 95033 || 109 | 王芳 | 女 | 1975-02-10 00:00:00 | 95031 || 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 |+-----+--------+------+---------------------+-------+6 rows in set (0.00 sec) 查询SCORE表中成绩在60到80之间的所有记录123456789101112mysql&gt; SELECT * FROM SCORE WHERE DEGREE BETWEEN 60 AND 80;+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 108 | 3-105 | 78.0 || 107 | 6-106 | 79.0 |+-----+-------+--------+6 rows in set (0.00 sec) 查询SCORE表中成绩为85，86或88的记录12345678mysql&gt; SELECT * FROM SCORE WHERE DEGREE IN(85, 86, 88);+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-245 | 86.0 || 105 | 3-105 | 88.0 || 101 | 6-166 | 85.0 |+-----+-------+--------+ 查询STUDENT表中“95031”班或性别为“女”的同学记录12345678910mysql&gt; SELECT * FROM STUDENT WHERE CLASS='95031' OR SSEX='女';+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 109 | 王芳 | 女 | 1975-02-10 00:00:00 | 95031 || 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 |+-----+--------+------+---------------------+-------+4 rows in set (0.00 sec) 以CLASS降序查询STUDENT表的所有记录123456789101112mysql&gt; SELECT * FROM STUDENT ORDER BY CLASS DESC;+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 108 | 曾华 | 男 | 1977-09-01 00:00:00 | 95033 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 101 | 李军 | 男 | 1976-02-20 00:00:00 | 95033 || 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 109 | 王芳 | 女 | 1975-02-10 00:00:00 | 95031 || 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 |+-----+--------+------+---------------------+-------+6 rows in set (0.00 sec) 以CNO升序、DEGREE降序查询SCORE表的所有记录123456789101112131415161718mysql&gt; SELECT * FROM SCORE ORDER BY CNO, DEGREE DESC;+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-105 | 92.0 || 107 | 3-105 | 91.0 || 105 | 3-105 | 88.0 || 108 | 3-105 | 78.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 103 | 3-245 | 86.0 || 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 107 | 6-106 | 79.0 || 101 | 6-166 | 85.0 || 108 | 6-166 | 81.0 |+-----+-------+--------+12 rows in set (0.00 sec) 查询“95031”班的学生人数1234567mysql&gt; SELECT COUNT(*) FROM STUDENT WHERE CLASS='95031';+----------+| COUNT(*) |+----------+| 3 |+----------+1 row in set (0.00 sec) 查询SCORE表中的最高分的学生学号和课程号1234567mysql&gt; SELECT SNO, CNO FROM SCORE WHERE DEGREE IN (SELECT MAX(DEGREE) FROM SCORE);+-----+-------+| SNO | CNO |+-----+-------+| 103 | 3-105 |+-----+-------+1 row in set (0.00 sec) 查询‘3-105’号课程的平均分1234567mysql&gt; SELECT AVG(DEGREE) FROM SCORE WHERE CNO='3-105';+-------------+| AVG(DEGREE) |+-------------+| 81.50000 |+-------------+1 row in set (0.00 sec) 查询SCORE表中至少有2名学生选修的并以3开头的课程的平均分数12345678mysql&gt; SELECT AVG(DEGREE) FROM SCORE GROUP BY CNO HAVING COUNT(CNO)&gt;1 AND CNO LIKE '3%';+-------------+| AVG(DEGREE) |+-------------+| 81.50000 || 76.33333 |+-------------+2 rows in set (0.00 sec) 查询最低分大于70，最高分小于90的SNO列12345678mysql&gt; SELECT SNO FROM SCORE GROUP BY SNO HAVING MIN(DEGREE)&gt;70 AND MAX(DEGREE)&lt;90;+-----+| SNO |+-----+| 105 || 108 |+-----+2 rows in set (0.00 sec) 查询所有学生的SNAME、CNO和DEGREE列12345678910111213141516171819202122232425262728293031323334353637mysql&gt; SELECT A.SNAME, B.CNO, B.DEGREE FROM STUDENT A, SCORE B WHERE A.SNO=B.SNO;+--------+-------+--------+| SNAME | CNO | DEGREE |+--------+-------+--------+| 陆君 | 3-245 | 86.0 || 匡明 | 3-245 | 75.0 || 王芳 | 3-245 | 68.0 || 陆君 | 3-105 | 92.0 || 匡明 | 3-105 | 88.0 || 王芳 | 3-105 | 76.0 || 李军 | 3-105 | 64.0 || 王丽 | 3-105 | 91.0 || 曾华 | 3-105 | 78.0 || 李军 | 6-166 | 85.0 || 王丽 | 6-106 | 79.0 || 曾华 | 6-166 | 81.0 |+--------+-------+--------+12 rows in set (0.00 sec)# 解法二使用内连接mysql&gt; SELECT STUDENT.SNAME, SCORE.CNO, SCORE.DEGREE FROM STUDENT INNER JOIN SCORE ON STUDENT.SNO=SCORE.SNO;+--------+-------+--------+| SNAME | CNO | DEGREE |+--------+-------+--------+| 陆君 | 3-245 | 86.0 || 匡明 | 3-245 | 75.0 || 王芳 | 3-245 | 68.0 || 陆君 | 3-105 | 92.0 || 匡明 | 3-105 | 88.0 || 王芳 | 3-105 | 76.0 || 李军 | 3-105 | 64.0 || 王丽 | 3-105 | 91.0 || 曾华 | 3-105 | 78.0 || 李军 | 6-166 | 85.0 || 王丽 | 6-106 | 79.0 || 曾华 | 6-166 | 81.0 |+--------+-------+--------+12 rows in set (0.00 sec) 查询所有学生的SNO、CNAME和DEGREE列123456789101112131415161718192021222324252627282930313233343536mysql&gt; SELECT A.SNO, B.CNAME, A.DEGREE FROM SCORE A, COURSE B WHERE A.CNO=B.CNO;+-----+-----------------+--------+| SNO | CNAME | DEGREE |+-----+-----------------+--------+| 103 | 操作系统 | 86.0 || 105 | 操作系统 | 75.0 || 109 | 操作系统 | 68.0 || 103 | 计算机导论 | 92.0 || 105 | 计算机导论 | 88.0 || 109 | 计算机导论 | 76.0 || 101 | 计算机导论 | 64.0 || 107 | 计算机导论 | 91.0 || 108 | 计算机导论 | 78.0 || 101 | 数据电路 | 85.0 || 108 | 数据电路 | 81.0 |+-----+-----------------+--------+11 rows in set (0.01 sec)# 解法二使用内连接mysql&gt; SELECT A.SNO, C.CNAME, B.DEGREE FROM STUDENT A INNER JOIN SCORE B INNER JOIN COURSE C ON A.SNO=B.SNO AND B.CNO=C.CNO;+-----+-----------------+--------+| SNO | CNAME | DEGREE |+-----+-----------------+--------+| 108 | 计算机导论 | 78.0 || 108 | 数据电路 | 81.0 || 105 | 操作系统 | 75.0 || 105 | 计算机导论 | 88.0 || 107 | 计算机导论 | 91.0 || 101 | 计算机导论 | 64.0 || 101 | 数据电路 | 85.0 || 109 | 操作系统 | 68.0 || 109 | 计算机导论 | 76.0 || 103 | 操作系统 | 86.0 || 103 | 计算机导论 | 92.0 |+-----+-----------------+--------+11 rows in set (0.00 sec) 查询所有学生的SNAME、CNAME和DEGREE列123456789101112131415161718192021222324252627282930313233343536mysql&gt; SELECT A.SNAME, B.CNAME, C.DEGREE FROM STUDENT A, COURSE B, SCORE C WHERE A.SNO=C.SNO AND B.CNO=C.CNO;+--------+-----------------+--------+| SNAME | CNAME | DEGREE |+--------+-----------------+--------+| 曾华 | 计算机导论 | 78.0 || 曾华 | 数据电路 | 81.0 || 匡明 | 操作系统 | 75.0 || 匡明 | 计算机导论 | 88.0 || 王丽 | 计算机导论 | 91.0 || 李军 | 计算机导论 | 64.0 || 李军 | 数据电路 | 85.0 || 王芳 | 操作系统 | 68.0 || 王芳 | 计算机导论 | 76.0 || 陆君 | 操作系统 | 86.0 || 陆君 | 计算机导论 | 92.0 |+--------+-----------------+--------+11 rows in set (0.00 sec)# 解法二内连接mysql&gt; SELECT STUDENT.SNAME, COURSE.CNAME, SCORE.DEGREE FROM STUDENT INNER JOIN SCORE INNER JOIN COURSE ON STUDENT.SNO=SCORE.SNO AND SCORE.CNO=COURSE.CNO;+--------+-----------------+--------+| SNAME | CNAME | DEGREE |+--------+-----------------+--------+| 曾华 | 计算机导论 | 78.0 || 曾华 | 数据电路 | 81.0 || 匡明 | 操作系统 | 75.0 || 匡明 | 计算机导论 | 88.0 || 王丽 | 计算机导论 | 91.0 || 李军 | 计算机导论 | 64.0 || 李军 | 数据电路 | 85.0 || 王芳 | 操作系统 | 68.0 || 王芳 | 计算机导论 | 76.0 || 陆君 | 操作系统 | 86.0 || 陆君 | 计算机导论 | 92.0 |+--------+-----------------+--------+11 rows in set (0.00 sec) 查询“95033”班所选课程的平均分12345678910111213141516mysql&gt; SELECT AVG(DEGREE) FROM SCORE INNER JOIN STUDENT S ON S.CLASS='95033';+-------------+| AVG(DEGREE) |+-------------+| 80.25000 |+-------------+1 row in set (0.00 sec)# 解法二mysql&gt; mysql&gt; SELECT AVG(DEGREE) FRO WHERE SNO IN(SELECT SNO FROM STUDENT WHERE CLASS='95033');+-------------+| AVG(DEGREE) |+-------------+| 79.66667 |+-------------+1 row in set (0.00 sec) 假设使用如下命令建立了一个grade表123456CREATE TABLE grade(low int,upp int,rank char(1));INSERT INTO grade VALUES(90,100,'A');INSERT INTO grade VALUES(80,89,'B');INSERT INTO grade VALUES(70,79,'C');INSERT INTO grade VALUES(60,69,'D');INSERT INTO grade VALUES(0,59,'E'); 查询所有同学的SNO、CNO和rank列 123456789101112131415161718mysql&gt; SELECT A.SNO, A.CNO, B.rank FROM SCORE A, grade B WHERE A.DEGREE BETWEEN low and upp;+-----+-------+------+| SNO | CNO | rank |+-----+-------+------+| 103 | 3-245 | B || 105 | 3-245 | C || 109 | 3-245 | D || 103 | 3-105 | A || 105 | 3-105 | B || 109 | 3-105 | C || 101 | 3-105 | D || 107 | 3-105 | A || 108 | 3-105 | C || 101 | 6-166 | B || 107 | 6-106 | C || 108 | 6-166 | B |+-----+-------+------+12 rows in set (0.00 sec) 查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录 12345678910mysql&gt; SELECT * FROM STUDENT WHERE SNO IN (SELECT SNO FROM SCORE WHERE CNO='3-105' AND DEGREE&gt;(SELECT DEGREE FROM SCORE WHERE SNO='109' AND CNO='3-105'));+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 || 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 108 | 曾华 | 男 | 1977-09-01 00:00:00 | 95033 |+-----+--------+------+---------------------+-------+4 rows in set (0.00 sec) 查询”95033”班和”95031”班全体学生的记录 123456789101112mysql&gt; SELECT * FROM STUDENT WHERE CLASS IN('95033', '95031');+-----+--------+------+---------------------+-------+| SNO | SNAME | SSEX | SBIRTHDAY | CLASS |+-----+--------+------+---------------------+-------+| 108 | 曾华 | 男 | 1977-09-01 00:00:00 | 95033 || 105 | 匡明 | 男 | 1975-10-02 00:00:00 | 95031 || 107 | 王丽 | 女 | 1976-01-23 00:00:00 | 95033 || 101 | 李军 | 男 | 1976-02-20 00:00:00 | 95033 || 109 | 王芳 | 女 | 1975-02-10 00:00:00 | 95031 || 103 | 陆君 | 男 | 1974-06-03 00:00:00 | 95031 |+-----+--------+------+---------------------+-------+6 rows in set (0.00 sec) 查询存在有85分以上成绩的课程CNO 12345678mysql&gt; SELECT CNO FROM SCORE GROUP BY CNO HAVING CNO IN (SELECT CNO FROM SCORE WHERE DEGREE&gt;85);+-------+| CNO |+-------+| 3-105 || 3-245 |+-------+2 rows in set (0.00 sec) 查询出“计算机系“教师所教课程的成绩表 12345678910111213141516171819202122232425262728293031mysql&gt; SELECT * FROM SCORE WHERE CNO IN(SELECT CNO FROM COURSE WHERE TNO IN(SELECT TNO FROM TEACHER WHERE DEPART='计算机系'));+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-245 | 86.0 || 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 103 | 3-105 | 92.0 || 105 | 3-105 | 88.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 107 | 3-105 | 91.0 || 108 | 3-105 | 78.0 |+-----+-------+--------+9 rows in set (0.00 sec)# 解法二mysql&gt; SELECT * FROM SCORE WHERE CNO IN(SELECT C.CNO FROM TEACHER T, COURSE C WHERE T.DEPART='计算机系' AND T.TNO=C.TNO);+-----+-------+--------+| SNO | CNO | DEGREE |+-----+-------+--------+| 103 | 3-245 | 86.0 || 105 | 3-245 | 75.0 || 109 | 3-245 | 68.0 || 103 | 3-105 | 92.0 || 105 | 3-105 | 88.0 || 109 | 3-105 | 76.0 || 101 | 3-105 | 64.0 || 107 | 3-105 | 91.0 || 108 | 3-105 | 78.0 |+-----+-------+--------+9 rows in set (0.00 sec)","link":"/database/mysql/pratices/"},{"title":"Gson","text":"Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象 添加依赖包项目结构管理–&gt;依赖–&gt;Library Dependency–&gt;搜索Gson（com.google.code.gson:gson:2.8.0) 安装Json快速生成实体类插件Setting–&gt;plugins–&gt;Browse Repositories–&gt;GsonFormat 设置快捷键Setting–&gt;Keymap–&gt;search–&gt;gson 使用在代码编辑区使用快捷键，然后输入JSON文档，就可以生成JSON实体类了 具体实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MainActivity extends AppCompatActivity { @BindView(R.id.edit_query) EditText mEditQuery; @BindView(R.id.tv_result) TextView mTvResult; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); } public void search(View view) { final String search_content = mEditQuery.getText().toString(); // get the json data and set the result in the TextView //first check the string if not chinese //is chinese only get the translation // is english get the all translation new AsyncTask&lt;String, Void, String&gt;() { @Override protected String doInBackground(String... params) { try { URL url = new URL(params[0]); URLConnection connection = url.openConnection(); InputStream input = connection.getInputStream(); InputStreamReader reader = new InputStreamReader(input); BufferedReader bufferedReader = new BufferedReader(reader); StringBuilder builder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { builder.append(line); } return builder.toString(); } catch (IOException e) { e.printStackTrace(); } return null; } @Override protected void onPostExecute(String s) { String result = \"\"; Gson gson = new Gson(); YouDao youDao = gson.fromJson(s, YouDao.class); if (RegularExpression.isChinese(search_content)) { result = youDao.getTranslation().get(0); } else { String temp = \"\\n\" + \"webTranslation:\" + \"\\n\"; List&lt;YouDao.WebBean&gt; webList = youDao.getWeb(); for (int i=0;i &lt;webList.size(); i++){ temp += webList.get(i).toString() + \"\\n\"; } result = youDao.getBasic().toString() + temp; } mTvResult.setText(result); super.onPostExecute(s); } }.execute(\"http://fanyi.youdao.com/openapi.do?keyfrom=\" + \"FloatingSearchApi&amp;key\" + \"=598006220&amp;type=data&amp;doctype=\" + \"json&amp;version=1.1&amp;q=\" + search_content); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package www.lollipopstudio.top.gsontest;import com.google.gson.annotations.SerializedName;import java.util.List;/** * 项目名称：GsonTest * 类描述： * 创建人：smileorigin * 创建时间：2017/3/16 16:26 * 修改人：smileorigin * 修改时间：2017/3/16 16:26 * 修改备注： */public class YouDao { /** * translation : [\"微笑\"] * basic : {\"us-phonetic\":\"smaɪl\",\"phonetic\":\"smaɪl\",\"uk-phonetic\":\"smaɪl\",\"explains\":[\"n. 微笑；笑容；喜色\",\"vt. 微笑着表示\",\"vi. 微笑\",\"n. (Smile)人名；(塞)斯米莱\"]} * query : smile * errorCode : 0 * web : [{\"value\":[\"微笑\",\"贾乃亮\",\"Smile (乐队)\"],\"key\":\"Smile\"},{\"value\":[\"再次微笑\",\"笑吧！东海\",\"再次微笑\"],\"key\":\"Smile Again\"},{\"value\":[\"オリジナル スマイル\"],\"key\":\"Original Smile\"}] */ private BasicBean basic; private String query; private int errorCode; private List&lt;String&gt; translation; private List&lt;WebBean&gt; web; public BasicBean getBasic() { return basic; } public void setBasic(BasicBean basic) { this.basic = basic; } public String getQuery() { return query; } public void setQuery(String query) { this.query = query; } public int getErrorCode() { return errorCode; } public void setErrorCode(int errorCode) { this.errorCode = errorCode; } public List&lt;String&gt; getTranslation() { return translation; } public void setTranslation(List&lt;String&gt; translation) { this.translation = translation; } public List&lt;WebBean&gt; getWeb() { return web; } public void setWeb(List&lt;WebBean&gt; web) { this.web = web; } public static class BasicBean { /** * us-phonetic : smaɪl * phonetic : smaɪl * uk-phonetic : smaɪl * explains : [\"n. 微笑；笑容；喜色\",\"vt. 微笑着表示\",\"vi. 微笑\",\"n. (Smile)人名；(塞)斯米莱\"] */ @SerializedName(\"us-phonetic\") private String usphonetic; private String phonetic; @SerializedName(\"uk-phonetic\") private String ukphonetic; private List&lt;String&gt; explains; public String getUsphonetic() { return usphonetic; } public void setUsphonetic(String usphonetic) { this.usphonetic = usphonetic; } public String getPhonetic() { return phonetic; } public void setPhonetic(String phonetic) { this.phonetic = phonetic; } public String getUkphonetic() { return ukphonetic; } public void setUkphonetic(String ukphonetic) { this.ukphonetic = ukphonetic; } public List&lt;String&gt; getExplains() { return explains; } public void setExplains(List&lt;String&gt; explains) { this.explains = explains; } @Override public String toString() { String result = \"\"; for (int i = 0; i &lt; getExplains().size(); i++) { if (i &lt; getExplains().size() - 1) { result += getExplains().get(i) + \"\\n\"; } else { result += getExplains().get(i); } } return \"en:\" + getUkphonetic() + \"\\n\" + \"us:\" + getUsphonetic() + \"\\n\" + \"Translation:\" + \"\\n\" + result; } } public static class WebBean { /** * value : [\"微笑\",\"贾乃亮\",\"Smile (乐队)\"] * key : Smile */ private String key; private List&lt;String&gt; value; public String getKey() { return key; } public void setKey(String key) { this.key = key; } public List&lt;String&gt; getValue() { return value; } public void setValue(List&lt;String&gt; value) { this.value = value; } @Override public String toString() { String result = \"\"; for (int i = 0; i &lt; getValue().size(); i++) { if (i &lt; getValue().size() - 1) { result += getValue().get(i) + \",\"; } else { result += getValue().get(i); } } return getKey() + \":\" + result; } }}","link":"/android/framework/gson/gson/"},{"title":"ActivityLaunchMode","text":"在默认情况下的我们多次打开同一个Activity时，系统会创建多个实例并把它们一一放入任务栈中，当我们单击back键，会发现这些Activity会一一回退。任务栈是一种”后进先出“的栈结构，这个比较好理解，每按一下back键就会有一个Activity出栈，直到栈空为止，当栈中无任何Activity的时候，系统就会回收这个任务栈。知道了Android默认的启动模式后我们就会发现一个问题：多次启动同一个Activity，系统重复创建多个实例，这样不是很傻吗？这样做的确有点傻，Android在设计的时候不可能不考虑这个问题，所以它提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance 启动模式standard标准模式，系统默认的模式。每次启动一个Activity都会重新建立一个新的实例，不管这个实例是否已经存在。被创建的实例的生命周期符合典型情况下Activity的生命周期，如上节描述，它的onCreate()、onStart()、onResume()都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中， singleTop栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate()、onStart()不会被系统调用，因为他并没有发生改变。如果新Activity的实例已经存在但不是位于栈顶，那么新Activity仍然会重新建立。举个例子，假设目前栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位于栈顶，这个时候假设要再次启动D，如果D的启动模式为singleTop，那么栈内的情况就为ABCD；如果D的启动模式为standard，那么由于D被重新创建，导致栈内的情况就变为ABCDD singleTask栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会被重新创建实例，和singleTop模式一样，系统也会回调其onNewIntent。具体一点，当一个具有singleTask模式的Activity请求启动后，比如Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放入栈中。如果存在A所需要的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中 比如当前任务栈S1中的情况为ABC，这个时候ActivityD以singleTask模式请求启动，其所需要的任务栈为S2，由于S2和D的实例均不存在，所以系统会先创建任务栈S2，然后再创建D的实例并将其入栈到S2 另一种情况是，假设D所需要的任务栈是S1，其他情况如上面例子1所示，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1 如果所需要的任务栈为S1，并且当前任务栈S1的情况为ADBS，根据任务栈内复用原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，且会导致栈内所有在D上面的Activity全部出栈，于是最终S1中的情况为AD singleInstance单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此模式的Activity只能单独的位于一个任务栈中，换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了 无论 Activity 是在新任务中启动，还是在与启动 Activity 相同的任务中启动，用户按“返回”按钮始终会转到前一个 Activity。 但是，如果启动指定 singleTask 启动模式的 Activity，则当某后台任务中存在该 Activity 的实例时，整个任务都会转移到前台。此时，返回栈包括上移到堆栈顶部的任务中的所有 Activity 如何给Activity指定启动模式 通过AndroidMenifest为Activity指定启动模式，如下所示 1234&lt;acticity android:name=\"com.test.activity\" android:launchMode=\"singleTask\" android:label=\"@string/app_name\"/&gt; 通过在Intent中设置标志位来为Activity指定启动模式，例如： 123Intent i = new Intent(this, OtherActivity.class);i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(i); 这来两种方式都可以为Activity指定启动模式，但是二者还是有区别的。首先优先级上第二种方式的优先级要高于第一种，当两种同时存在时，以第二种方式为准；其次，上述两种方式在限定范围上有所不同，比如，第一种方式无法直接为Activit设定FLAG_ACTIVITY_CLEAR_TOP标识，而第二种方式无法为Activity指定singleInstance模式 通过adb命令获取Activity栈 配置adb环境 找到SDK安装目录，并找到platform-tools和tools两个文件夹 将找到的两个文件夹的路径配置到环境变量中，如下图所示，最后在Path环境变量参数中加入%adb% 打开cmd窗口，执行adb shell dumpsys activity即可显示现在的Activity栈的情况 内容补充如果有两个Activity B、C是singleTask启动模式，此时从A Activity启动B，再从B启动C，此时的栈中情况为ABC，最后再从C启动B，那么此时的Activity栈中的情况是什么呢？答案是AB，因为此时栈中已经有B了，在不新建B的情况下要把B移动到栈顶唯一的办法只有将C移出栈了，验证如下图所示： Activity的Flags FLAG_ACTIVITY_NEW_TASK 这个标记位的作用是为Activity指定”singleTask”启动模式，其效果和在XML中指定该启动模式相同 FLAG_ACTIVITY_SINGLE_TOP 这个标记位的作用是为Activity指定”singleTop”启动模式，其效果和在XML中指定该启动模式相同 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当他活动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个标记位一般会和singleTask启动模式一起出现，在这种情况下，被启动的Activity的实例如果已经存在，那么系统就会调用它的onNewIntent()。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶，通过前面的补充内容，我们已经能知道了singleTask模式默认就具有此标记位的效果 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有此标记位的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents=&quot;true&quot; one more thing本文测试代码地址：https://github.com/SMILEORIGIN/ActivityStartModel","link":"/android/book/android-art/activity-launch-mode/"},{"title":"Activity 的生命周期(读书笔记)","text":"Activity 有两种生命周期：典型情况下的生命周期和异常情况下的生命周期。典型情况下的生命周期是指在有用户参与的情况下，Activity 所经过的生命周期的改变。异常情况下的生命周期是指 Activity 被系统回收或者由于当前设备的 Configuration 发生改变从而导致被销毁重建 典型情况下的生命周期分析 onCreate() 表示Activity正在被创建，这是生命周期的第一个方法。在这个方法中，我们可以做一些初始化工作，比如调用setContentView去加载界面布局资源、初始化Activity所需数据等 onRestart() 表示Activity正在重新启动。一般情况下，当当前Activity从不可见变为可见状态时，onRestart()就会被调用。这种情形一般是用户行为所导致的，比如用户按Home建切换到桌面或者用户打开了一个新的Activity，这时当前Activity就会暂停，也就是onPause()和onStop()被执行了，接着用户又回到了这个Activity，也就会出现这种情况 onStart() 表示Activity正在被启动，即将开始，这个时候其实可以理解为Activity已经显示出来了，但是我们还看不到，无法进行交互 onResume() 表示Activity已经可见了，并且出现在前台并未开始活动。onStart()的时候Activity还在后台不可见，onResume()的时候已经在前台了用户可见 onPause() 表示Activity正在停止，正常情况下，紧接着onStop()就会被调用。在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume()就会被调用。在系统急需内存的情况下，处于onPause()的Activity可能会被直接回收而不经过onStop()和onDestory()方法，因此此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容等，在onPause()中所执行的任务应该是耗时比较短的，因为onPause()必须先执行完，新的Activity的onResume()才会执行，如果此时执行的任务比较耗时将会有影响到下一个Activity的开启，造成很不好的用户体验 onStop() 表示Activity即将终止，可以做一些稍微轻量级的回收工作，不能太耗时 onDestroy() 表示Activity即将被销毁，这是Activity生命周期中的最后一个回调，在这里我们可以做一些回收工作和最终的资源释放 生命周期图如下：（Google Api Guide上的） 典型情况下的生命周期–补充 当用户打开新的Activity或者切换到桌面的时候，回调过程为：onPause()–&gt;onStop()。这里有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调onStop() 当我们在MainActivity打开设置为透明的TransparencyActivity时的启动过程如图所示可证上述结论： 当我们按返回键回到MainActivity时触发的是MainActivity的onResume()而不是onRestart()，因为打开Transparency的时候并没有触发MainActivity的onStop()，此过程在生命周期图种也有展示 当启动正常Activity时，如图所示： 当用户按back建返回时默认的情况为：onPause()–&gt;onStop()–&gt;onDestroy() 从TempActivity通过按back键后退回MainActivity： 当按在TransparencyActivity按home键返回桌面，在进入应用时我们会发现很奇特的现象，绿框内为启动Transparency的过程，红框内为按home键返回桌面的过程，蓝框内为重新进入应用的过程 在重新进入应用时我们发现两个MainActivity和TransparencyActivity都重新加载了，因为TransparencyActivity是被定义为透明的（设置Activity的主题的true时，定义Activity为“透明的”但此时，Activity是否为透明还得看具体的设置，但它已经被系统认定为是透明的了），而MainActivity在这种情况下下是属于用户可见的，因此当打开TransparencyActivity时才没有执行onStop()，执行onStop()后Activity就属于用户不可见，即看不到Activity中的内容了 下图为在MainActivity中打开正常的TempActivity然后按home键回到桌面再重新进入应用的过程 onStart()、onResume()、onPause()、onStop()从描述上差不多，对我们来说的实质不同是什么？ onStart()和onPause()是从Actiivty是否可见这个角度来回调的，而onResume()和onStop()是从Activity是否处于前台这个角度来回调的，除此之外，在实际使用中没有其他明显区别 异常情况下的生命周期分析 资源相关的系统配置发生改变导致Activity被杀死并重新创建 常见的如：屏幕方向发生改变，且应用有设置横竖屏模式 当系统配置发生改变后，Activity会被销毁，onPause()、onStop()、onDestroy(0均会被调用，同时由于系统是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用时机是在onStop()之前，它和onPause()没有既定的时序关系，它既可能在onPause()之前调用，也可能在onPause()之后调用。需要强调的一点是，这个方法只会出现在Activity被异常从终止的情况下，正常情况下系统不会回调这个方法。当Activity被重新创建后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传给onRestoreInstanceState和onCreate()来判断Activity是否被重建，如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState()的调用时机在onStart()之后 保存和恢复View的层次结构，系统的工作流程：首先Activity被意外终止时，Activity会调用onSaveInstanceState去保存数据，然后Acticity会委托Windows去保存数据，接着Windows在委托它上面的顶级容器去保存数据。最后顶级容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成来了。可以发现，这是一种典型的委托思想，上层委托下层、父容器委托子元素去处理一件事情，这种思想在Androud中有很多应用，比如View的绘制过程、事件分发等都是采用类似的思想。 我们在MainActivity中进行转屏可见如下运行过程，系统只在Activity异常终止的时候才会调用onSaveInstanceState与onRestoreInstanceState来储存和恢复数据，其他情况不会触发这个过程。但是按Home键或者启动新Activity仍然会单独触发onSaveInstanceState的调用 资源内存不足导致优先级的Activity被杀死 当系统内存不足时，系统就会按照以下优先级去杀死目标Activity所在的进程，并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数据。如果一个进程中没有四大组件在运行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独立的运行在后台中，这样进程很容易就被杀死。比较好的方法是将后台工作放入Servie中从而保证进程有一定的优先级这样就不容易轻易的被系统杀死 前台Activity—–正在和用户交互的Activity，优先级别最高 可见但非前台Activity—–比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和前台用户直接交互 后台Activity—–已经被暂停的Activity，比如执行了onStop()，优先级别低 解决系统配置发生改变后Activity会被重新创建的问题 要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 “orientation” 和 “keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。您可以在该属性中声明多个配置值，方法是 ”|“ 字符分隔这些配置值 例如，以下清单文件代码声明的 Activity 可同时处理屏幕方向变更和键盘可用性变更：123&lt;activity android:name=\".MyActivity\" android:configChanges=\"orientation|keyboardHidden\" android:label=\"@string/app_name\"&gt; 更多的configChanges项目和含义请看下表：","link":"/android/book/android-art/activity-life-cycle/"},{"title":"Flask","text":"记录学习 Flask 过程的笔记 Http方法Http有多个访问URL的方法，默认情况下，路由只回应GET请求，但是通过app.route装饰器传递methods参数可以改变这个性为： 12@app.route('/login', method=['GET', 'POST'])@app.route('/j/item/&lt;id&gt;', methods=['DELETE', '[POST']) 如果存在GET，那么也会自动地添加HEAD方法，无需干预。它会确保遵照HTTP RFC（描述HTTP协议的文档）处理HEAD请求，所以你完全可以忽略这部分的HTTP规范。从Flask 6.0起，它也实现了OPTIONS的自动处理下面简要介绍HTTP方法和使用场景 GET:获取资源，GET操作应该是幂等的 HEAD:想要获取信息，但是只关心消息头。应用应该像处理GET请求一样来处理它，但是不返回实际内容 POST:创建一个新的资源 PUT:完整的替换资源或者创建资源。PUT操作虽然有副作用，但应该是幂等的 OPTIONS:获取资源支持的所有HTTP方法 PATCH:局部更新，修改某个已有的资源（幂等：表示在相同的数据和参数下，执行一次或多次产生的效果是一样的） 使用url_for生成路径代替绝对路径不要在模板中写死静态文件路径，应该用url_for生成路径 1url_for('static', filename='style.css') 生成的路径就是’/static/style.css’当然我们也可以定制静态文件的真实目录： 1app = Flask(__name__, static_folder='/tmp') 那么访问’https://localhost:9000/static/style.css'，也就是访问/tmp/style.css这个文件 Flask-Migrate在开发过程中我们经常会修改到model，此时一般的操作是先删除表，再使用Flask-SQLAlchemy的create_all()重新建表，数据就会全部丢失了Flask-Migrate是数据库迁移框架，就像代码版本控制工具会监控代码改动一样，一个数据库迁移框架能跟踪数据库表的变化，并且能把新的改动应用到旧的表中 安装 1pip install flask-migrate 使用Flask-Script命令行实现Flask-Migrate 12345678910111213141516171819202122# manage.py# 官方示例from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommand app = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db' db = SQLAlchemy(app)migrate = Migrate(app, db) manager = Manager(app)manager.add_command('db', MigrateCommand) class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(128)) if __name__ == '__main__': manager.run() 运行 初始化migrate本地仓库 1python manage.py db init 开始迁移 1python manage.py db migrate 更新数据库 1python manage.py db upgrade 获取帮助信息 1python manage.py db --help Requirements应用应该包含一个requirements.txt，它记录了有着准确版本号的所有包依赖，能在其它环境下使用该文件快速安装所需要的依赖 自动生成requirements.txt文件,命令行输入以下命令 1pip freeze &gt;requirements.txt 在新环境中，如果要快速恢复需要的依赖，只需执行以下命令即可 1pip install -r requirements.txt","link":"/python/framework/flask/flask-coding-technique/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Experience","slug":"Experience","link":"/tags/Experience/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"Privoxy","slug":"Privoxy","link":"/tags/Privoxy/"},{"name":"ProxyChains4","slug":"ProxyChains4","link":"/tags/ProxyChains4/"},{"name":"Debian","slug":"Debian","link":"/tags/Debian/"},{"name":"CommandLine","slug":"CommandLine","link":"/tags/CommandLine/"},{"name":"Center OS","slug":"Center-OS","link":"/tags/Center-OS/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Translate","slug":"Translate","link":"/tags/Translate/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"Bigbang","slug":"Bigbang","link":"/tags/Bigbang/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"Qiniu","slug":"Qiniu","link":"/tags/Qiniu/"},{"name":"Image Hosting Service","slug":"Image-Hosting-Service","link":"/tags/Image-Hosting-Service/"},{"name":"EffectivePython","slug":"EffectivePython","link":"/tags/EffectivePython/"},{"name":"Advices","slug":"Advices","link":"/tags/Advices/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"uWsgi","slug":"uWsgi","link":"/tags/uWsgi/"},{"name":"Supervisor","slug":"Supervisor","link":"/tags/Supervisor/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Original","slug":"Original","link":"/tags/Original/"},{"name":"HexoBlog","slug":"HexoBlog","link":"/tags/HexoBlog/"},{"name":"A byte of Python","slug":"A-byte-of-Python","link":"/tags/A-byte-of-Python/"},{"name":"Virtualenv","slug":"Virtualenv","link":"/tags/Virtualenv/"},{"name":"Kodi","slug":"Kodi","link":"/tags/Kodi/"},{"name":"Raspberry","slug":"Raspberry","link":"/tags/Raspberry/"},{"name":"SSD1306","slug":"SSD1306","link":"/tags/SSD1306/"},{"name":"Respberry","slug":"Respberry","link":"/tags/Respberry/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"Share","slug":"Share","link":"/tags/Share/"},{"name":"Resources","slug":"Resources","link":"/tags/Resources/"},{"name":"Single-Chip Microcomputer","slug":"Single-Chip-Microcomputer","link":"/tags/Single-Chip-Microcomputer/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"NonOriginal","slug":"NonOriginal","link":"/tags/NonOriginal/"},{"name":"Utils","slug":"Utils","link":"/tags/Utils/"},{"name":"Vibrate","slug":"Vibrate","link":"/tags/Vibrate/"},{"name":"Guide","slug":"Guide","link":"/tags/Guide/"},{"name":"Preference","slug":"Preference","link":"/tags/Preference/"},{"name":"IO","slug":"IO","link":"/tags/IO/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Multilist","slug":"Multilist","link":"/tags/Multilist/"},{"name":"MD5","slug":"MD5","link":"/tags/MD5/"},{"name":"PAT","slug":"PAT","link":"/tags/PAT/"},{"name":"BasicLevel","slug":"BasicLevel","link":"/tags/BasicLevel/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Procedure","slug":"Procedure","link":"/tags/Procedure/"},{"name":"Pratices","slug":"Pratices","link":"/tags/Pratices/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"Gson","slug":"Gson","link":"/tags/Gson/"},{"name":"Android Art","slug":"Android-Art","link":"/tags/Android-Art/"},{"name":"ApplicationComponents","slug":"ApplicationComponents","link":"/tags/ApplicationComponents/"},{"name":"Activity","slug":"Activity","link":"/tags/Activity/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Another","slug":"Another","link":"/categories/Another/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Raspberry","slug":"Raspberry","link":"/categories/Raspberry/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Arithmetic","slug":"Arithmetic","link":"/categories/Arithmetic/"},{"name":"GSON","slug":"GSON","link":"/categories/GSON/"}]}